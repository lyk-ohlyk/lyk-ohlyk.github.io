<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="wizlyk">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="wizlyk">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="wizlyk">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>wizlyk</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">wizlyk</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">wizlyk的代码小天地</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/11/29/ShadowAlgorithms/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wizlyk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wizlyk">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/29/ShadowAlgorithms/" class="post-title-link" itemprop="url">ShadowAlgorithms</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-11-29 21:43:27" itemprop="dateCreated datePublished" datetime="2022-11-29T21:43:27+08:00">2022-11-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-30 21:54:35" itemprop="dateModified" datetime="2022-11-30T21:54:35+08:00">2022-11-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="月移疏影上东墙——简述阴影映射算法"><a href="#月移疏影上东墙——简述阴影映射算法" class="headerlink" title="月移疏影上东墙——简述阴影映射算法"></a>月移疏影上东墙——简述阴影映射算法</h1><blockquote>
<p>Above all shadows rides the Sun</p>
<p>and Stars for ever dwell:</p>
<p>I will not say the Day is done,</p>
<p>nor bid the Stars farewell  </p>
<p>― <strong>J·R·R·托尔金，《魔戒：王者归来》</strong></p>
</blockquote>
<p>正如被晨曦拉长的幢幢高楼，正如夏日微风中的斑驳树影，是阴影让光变得更加跳脱、丰富。本文简述了在虚拟场景中模拟出真实世界的阴影效果的实时渲染方法——阴影映射（Shadow mapping）的基本原理和其相关算法，同时介绍了阴影映射算法存在的问题以及软阴影现象，希望能帮助大家对阴影映射有一个大概的认识。</p>
<h2 id="如何模拟真实世界中的阴影？"><a href="#如何模拟真实世界中的阴影？" class="headerlink" title="如何模拟真实世界中的阴影？"></a>如何模拟真实世界中的阴影？</h2><p>在我们的宏观世界中，光沿着直线传播，并且会被物体吸收，同时形成反射和折射。对于阴影来说，我们只需要模拟光被物体吸收（挡住）就可以了。这要怎么做呢？</p>
<img style="float: center;" src="/2022/11/29/ShadowAlgorithms/EyeShadow.png" width="400">
<center>图1、阴影产生示意图</center>

<p>如图1所示，当眼睛看到的地方和光源之间有阻挡的时候，这个地方就处于阴影之中。我们在把一个场景画到屏幕的时候，就是把场景的一个个位置投射到屏幕的像素上；那么，对于画在屏幕上的每个像素对应的位置，都判断一下这个位置和光源之间有没有阻挡，不就可以知道这个位置是不是在阴影中了么？</p>
<p>是的，没错！你甚至可以只用<a target="_blank" rel="noopener" href="https://www.shadertoy.com/view/cdfSWf">二三十行shadertoy代码</a>就实现这样的效果。但是这样做有一个问题，场景中的物体往往很复杂，判断有没有阻挡需要计算射线与场景中物体的相交，这是一个很费时的操作；一般来说，而如果在游戏中每个像素都这样做，那计算量就有些太大了，前一天的阴影还没画完，后一天太阳都出来了。有没有办法，不算射线与物体的相交，也能知道一个位置是否处于阴影之中呢？</p>
<h2 id="阴影映射（Shadow-Mapping-）的由来"><a href="#阴影映射（Shadow-Mapping-）的由来" class="headerlink" title="阴影映射（Shadow Mapping ）的由来"></a>阴影映射（Shadow Mapping ）的由来</h2><h3 id="什么是阴影映射？"><a href="#什么是阴影映射？" class="headerlink" title="什么是阴影映射？"></a>什么是阴影映射？</h3><p>在计算阴影时，我们是真的想知道光被什么东西挡住了么？不，我们只关心光是否被挡住。那么，其实我们只需要知道被计算的位置和光源之间有没有东西就可以了！</p>
<p>在将场景绘制到屏幕时，人们往往会记录一个像素对应的位置距离摄像机的距离（即深度），并把这些深度保存在一张和屏幕一样大的图片上以方便一些其他的计算，这样的记录深度的图被称作深度图（Depth map）。深度图的每个像素，记录了向这个像素的方向看过去的最近的距离。</p>
<img style="float: center;" src="/2022/11/29/ShadowAlgorithms/DepthSquirrel.png" width="400">
<center>图2、一个松鼠模型的深度图，颜色越白表示离相机越近
    (图源：A Gauss-Newton Approach to Real-Time Monocular Multiple Object Tracking)</center>

<p>回到我们刚才计算阴影的问题，假如我们知道了对于光源来说各个方向的最近的距离，那么对于场景中的每个位置，我们都看它离光源的距离比这个最近距离大还是小，不就可以知道该位置是不是在阴影中了么——若离光源的距离大于对应方向的最近距离，则说明前面有东西遮挡；若离光源的距离等于对应方向的最近距离，说明该位置被光源照亮了，即没有阴影。</p>
<p>所以我们只需要在光源处，对场景计算一张深度图，对于场景中的每个位置，都把他投射到这张深度图上，将该位置的深度与深度图上对应像素的深度进行对比，就能知道这个位置是否处于阴影中。这种使用光源的深度图来计算阴影的方法，就叫做阴影映射，也就是Shadow mapping【1】，而这张深度图，则被称作阴影贴图（Shadow map）。</p>
<p>来看一个来自于<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE">维基百科的阴影映射</a>的例子。图3(a)是一个有阴影的帕特农神庙模型，光源为在左侧向右照射的平行光。</p>
<p><img style="display: inline;" src="/2022/11/29/ShadowAlgorithms/Wiki-ShadowMapping\7fin.png" width="224"><img style="display: inline;" src="/2022/11/29/ShadowAlgorithms/Wiki-ShadowMapping\3noshadow.png" width="224"><img style="display: inline;" src="/2022/11/29/ShadowAlgorithms/Wiki-ShadowMapping\1light.png" width="224"><img style="display: inline;" src="/2022/11/29/ShadowAlgorithms/Wiki-ShadowMapping\2shadowmap.png" width="224"></p>
<center>(a)一个有阴影的“帕特农神庙”   (b)无阴影  (c) 光源视角 (d) 阴影贴图</center>
<center>图3、一个有阴影的“帕特农神庙”的计算过程</center>

<p>在使用阴影映射前，场景是没有阴影的，如图3(b)所示。要从图3(b)中得到图3(a)的结果，我们需要从光源处计算一张深度贴图。图3(c)即为从光源视角看向场景的样子。计算出来的阴影贴图为图3(d)，图3(d)和上面的图2的深度图一样，都是颜色越白，表示离观察点（图2为摄像机、图3(d)为光源）越近。有了深度贴图，那么就可以进行深度测试，判断图3(b)中的哪些像素是处于阴影中了，深度测试的结果见图4。有了图4，就能把渲染的结果，从图3(b)变为图3(a)了！</p>
<img style="float: center;" src="/2022/11/29/ShadowAlgorithms/Wiki-ShadowMapping\5failed.png" width="300">
<center>图4、在阴影贴图上深度测试失败的像素（图中白色部分），即处于阴影中的像素</center>

<p>总的来说，阴影映射是一个有两个渲染 pass 的算法：在第一个 pass，先在光源处，将场景物体离光源的深度写进阴影贴图；在第二个 pass，进行深度判断，将整个含阴影的场景渲染出来。</p>
<h3 id="阴影映射的问题"><a href="#阴影映射的问题" class="headerlink" title="阴影映射的问题"></a>阴影映射的问题</h3><p>不过现在，阴影映射还有一些很明显的问题没有解决：</p>
<h4 id="一、走样（锯齿）问题"><a href="#一、走样（锯齿）问题" class="headerlink" title="一、走样（锯齿）问题"></a>一、走样（锯齿）问题</h4><p>这是所有在屏幕空间使用离散缓存的算法都存在的问题：不论我们的阴影贴图有多大，它的分辨率总是有限的；而有限的分辨率，必定会在某些场合不够适用；对于阴影贴图来说，其表现就是出现阴影锯齿（Aliasing），或是走样的现象。</p>
<img style="float: center;" src="/2022/11/29/ShadowAlgorithms/ninja.jpg" width="500">

<p>​图5、有锯齿的阴影（图源：<a target="_blank" rel="noopener" href="https://developer.nvidia.com/gpugems/gpugems/part-ii-lighting-and-shadows/chapter-11-shadow-map-antialiasing">GPUGems - Chapter-11</a>）</p>
<p>这种出现锯齿的表现误差，又被人们划分成了由透视产生的锯齿(Perspective aliasing)和由投影产生的锯齿(Projection aliasing)【2】。</p>
<img style="float: center;" src="/2022/11/29/ShadowAlgorithms/AliasingError.png" width="500">

<p>​​<center>图6、阴影贴图锯齿的产生原因示意图（图源：<a target="_blank" rel="noopener" href="https://developer.nvidia.com/gpugems/gpugems3/part-ii-light-and-shadows/chapter-10-parallel-split-shadow-maps-programmable-gpus">GPUGems3 - Chapter 10</a>）​</center></p>
<p>图6解释了锯齿产生的原因：图6表示了一束平行光从上往下照射，相机位于左侧的场景，我们考虑图像中勇士的手臂的阴影；<em><strong>n</strong></em>表示相机的近平面的距离（假设屏幕绘制在近平面），<em><strong>f</strong></em>表示相机的远平面的距离，<em><strong>s</strong></em>为归一化后的阴影平面，<em><strong>z</strong></em>表示勇士手臂离相机的距离，<em><strong>ds</strong></em>是勇士手臂投影到在阴影平面上的长度，<em><strong>dp</strong></em>是勇士手臂投影到屏幕上的长度。此时，阴影贴图的走样误差（aliasing error）可以被表示为</p>
<img src="https://latex.codecogs.com/svg.latex?\Large&space;\frac{\mathrm{d}p}{\mathrm{d}s}=n\frac{\mathrm{d}z}{z\mathrm{d}s}\frac{\mathrm{cos}\phi}{\mathrm{cos}\theta}" title="Aliasing error">

<p>其中，</p>
<img src="https://latex.codecogs.com/svg.latex?\Large&space;\frac{\mathrm{d}z}{z\mathrm{d}s}">

<p>是由透视产生的走样项，而</p>
<img src="https://latex.codecogs.com/svg.latex?\Large&space;\frac{\mathrm{cos}\phi}{\mathrm{cos}\theta}" title="Aliasing error">

<p>是由投影产生的走样项。</p>
<p>可见，由投影产生的锯齿是由光源位置、相机位置以及物体的几何（法线方向）决定的，而由透视产生的锯齿是由于透视的缩短现象造成的，所以人们研究 Shadow mapping 的锯齿问题（或分辨率问题），都是在尝试解决由<strong>透视</strong>产生的问题。比如：</p>
<ul>
<li><strong>透视阴影贴图（perspective shadow maps ，PSM）</strong>【2】：在透视变换后的空间生成阴影贴图，大大减少了由透视产生的锯齿，并且更加充分的利用了贴图分辨率。</li>
</ul>
<img style="float: center;" src="/2022/11/29/ShadowAlgorithms/PSM.png" width="700">
<center>图7、左图为世界空间、右图为透视变换后的空间（图源：Perspective shadow maps）</center>

<ul>
<li><p>使用多分辨率贴图的方法，如<strong>自适应阴影贴图（Adaptive Shadow Maps ，ASM）</strong>【3】。自适应阴影贴图通过量化阴影贴图的像素对最终绘制的图片的贡献，自适应地为需要高分辨率的地方计算高分辨率贴图，从而得到一个高质量的结果。这种方法更适用于离线渲染，而对于实时渲染来说效率有所不足。</p>
</li>
<li><p>使用多张阴影贴图，来达到不同位置有不同分辨率的效果，这往往是大场景的动态阴影的解决方案。<strong>平行分割阴影贴图(Parallel-Split Shadow Maps，PSSM)<strong>【4】，又被称为</strong>级联阴影贴图(Cascaded Shadow Maps，CSM)<strong>是业界常用的方法。算法基于一个事实——物体离相机越远，绘制没有锯齿的物体阴影所需要的阴影贴图分辨率就越小。</strong>平行分割阴影贴图算法</strong>（PSSM）将相机视锥按不同的深度划分成几个部分，并以此去划分光源视锥；同时为了更大效率地利用贴图分辨率，PSSM还计算了场景的中物体的包围盒（Axis-aligned bounding box）来帮助光源视锥的划分（更一般的做法是直接求相机视锥划分后的包围盒）。光源视锥划分好后，再对每个划分的部分分别计算深度贴图，最后进行场景的渲染。由于不同的阴影层级之间使用了不同的阴影贴图，所以在不同层级的边界往往会出现阴影精度不连续的现象；从图8可以看出，不同的层级之间的阴影贴图是有重叠区域的，通过对层级边界的阴影在不同阴影贴图上插值，可以减弱阴影精度不连续的现象。</p>
</li>
</ul>
<img style="float: center;" src="/2022/11/29/ShadowAlgorithms/CSM.png" width="600">
<center>图8、级联阴影贴图示意图，图中相机视锥被划分为4个部分，红框为每个部分的光源视锥的包围盒</center>

<h4 id="二、自遮挡及阴影脱离问题"><a href="#二、自遮挡及阴影脱离问题" class="headerlink" title="二、自遮挡及阴影脱离问题"></a>二、自遮挡及阴影脱离问题</h4><p>除了锯齿现象，阴影映射算法（Shadow mapping）还有自遮挡（self occlusion）引发的阴影失真（Shadow acne）的问题。</p>
<img style="float: center;" src="/2022/11/29/ShadowAlgorithms/shadow_acne.png" width="450">
<center>图9：阴影失真问题（水壶：我挡我自己）（图源：http://ohyecloudy.com/pnotes/archives/377/）</center>

<p>如图9所示，虽然图片中的水壶的阴影被画了出来，但整个场景却被一道道奇怪的黑色条纹笼罩，仿佛有一层纱把灯挡住一样。这是为什么呢？</p>
<p>这也是因为我们的分辨率有限产生的。由于我们是用的阴影贴图来描述整个场景，每一个阴影贴图的像素对应了一块区域，而这块区域的深度被假设成一致的。图10描述了为什么这样会出现自遮挡的问题：图10中假设光源从左上照射向右下，照到了长条形的地板上；每个黄色的箭头，都对应一个阴影贴图的像素；图中蓝色的阶梯状边界，就是阴影贴图所表现的场景的深度。</p>
<img style="float: center;" src="/2022/11/29/ShadowAlgorithms/shadow_mapping_self_occlusion.png">
<center>图10、阴影失真原理示意图</center>

<p>我们的地面是连续的，而阴影贴图的像素是离散的，贴图的深度只能看作是对连续的地面深度的近似。所以，可以看到在一个阴影贴图像素所表示的地面上，会同时存在阴影中和非阴影中两个状态；整个地面上，阴影区域和非阴影区域交替出现，形成自遮挡的现象。要怎么避免自遮挡现象呢？</p>
<p>当然了，如果光源方向完全垂直于地面的话，这个阶梯就和地面重合了，这种自遮挡现象自然就没有了；而对于不是垂直的情况，可以通过增加一个偏移来避免自遮挡——就是把这个蓝色的阶梯向光照方向移动一段距离，阴影的部分自然就少了，从而避免了自遮挡现象（图11）。</p>
<img style="float: center;" src="/2022/11/29/ShadowAlgorithms/shadow_mapping_bias.png">
<center>图11、增加偏移量以避免自遮挡现象</center>

<p>但是，把阶梯移动后，又有了新的问题：强行加上偏移，必然会使一些原本正确的阴影变的看不见了，这就是阴影脱离（Detached shadow）现象，人们又调皮的给了它一个另外的名字——彼得潘现象（Peter Panning）。</p>
<p><img style="display: inline;" src="/2022/11/29/ShadowAlgorithms/rtr4-detached-shadow.png" width="400"><img style="display: inline;" src="/2022/11/29/ShadowAlgorithms/peter-pan.png" width="600"></p>
<p>(a)增加阴影偏移后，脚的阴影消失（图源：<a target="_blank" rel="noopener" href="https://www.realtimerendering.com/figures/RTR4.07.12.Peters_demo.png">Real-Time Rendering</a>）         (b)小飞侠彼得潘正尝试抓住自己的影子（图源：Walt Disney Productions）</p>
<center>图12、阴影脱离（Detached shadow）现象</center>

<p>现在并没有一个好的解决阴影脱离现象的方法，只能尽量减少阴影偏移量，来避免阴影脱离现象过于明显。</p>
<h3 id="从渲染方程的角度看-Shadow-mapping"><a href="#从渲染方程的角度看-Shadow-mapping" class="headerlink" title="从渲染方程的角度看 Shadow mapping"></a>从渲染方程的角度看 Shadow mapping</h3><p>从我们上面的讨论可以发现，Shadow mapping 是将阴影的计算从渲染中分离了出来，算法先是计算了一个像素是否在阴影中（即对于光源的可见性），然后再将阴影的结果给到渲染的过程，从而得到最终的图像。那么，这样做是合理的么？是否存在一些情况，不能这样做呢？</p>
<p>在回答这些问题前，我们先来看一个积分的近似。</p>
<h4 id="一个数学近似"><a href="#一个数学近似" class="headerlink" title="一个数学近似"></a>一个数学近似</h4><p>对于连续的函数 <em>f</em> 和 <em>g</em>，在积分区间 <img src="https://latex.codecogs.com/svg.latex?\Large&space; \Omega" title="Aliasing error">上，由定积分的均值定理，存在 <img src="https://latex.codecogs.com/svg.latex?\Large&space; a \in \Omega "> 满足下面这个等式：</p>
<img src="https://latex.codecogs.com/svg.latex?\Large&space; \int_{\Omega} f(x)g(x)\,\mathrm{d}x = f(a)\int_{\Omega}g(x) \,\mathrm{d}x ">

<p>如果我们用 <img src="https://latex.codecogs.com/svg.latex?\Large&space; \frac{\int_{\Omega}f(x)\mathrm{d}x}{\int_{\Omega}\mathrm{d}x}"> 来近似 <em>f(a)</em> 的话，就得到了下面这个约等式：</p>
<img src="https://latex.codecogs.com/svg.latex?\Large&space; \int_{\Omega} f(x)g(x)\,\mathrm{d}x\approx\frac{\int_{\Omega}f(x)\mathrm{d}x}{\int_{\Omega}\mathrm{d}x}\cdot\int_{\Omega}g(x) \,\mathrm{d}x ">

<p>这个约等式在满足下面的任一条件的情况下会比较准确：</p>
<ul>
<li><em>f(x)</em> 的支撑集（Support）比较小，可理解为 <em>f(x)</em> 的积分域比较小。</li>
<li><em>g(x)</em> 在积分区间内比较光滑（Smooth），即其值变化不大。</li>
</ul>
<h4 id="近似的渲染方程"><a href="#近似的渲染方程" class="headerlink" title="近似的渲染方程"></a>近似的渲染方程</h4><p>渲染方程可以被写为：</p>
<img style="float: center;" src="/2022/11/29/ShadowAlgorithms/RenderEquation.png">

<p>其中，橙色框里面为方程中的可见项（Visibility）。将上面的约等式套用至渲染方程，可以得到：</p>
<img style="float: center;" src="/2022/11/29/ShadowAlgorithms/RenderEquationApproximation.png">

<p>这个约等式把可见项从积分中单独拿了出来，可以先计算可见项，再计算光照相关的部分——这不就是我们的 Shadow mapping 的思路么？可见，这个近似正是 Shadow mapping 背后的原理。于是，可以知道 Shadow mapping 更适用于以下的情况：</p>
<ul>
<li><img src="https://latex.codecogs.com/svg.latex?\Large&space; V(p, \omega_i)">的支撑集比较小的时候——即积分的范围比较小的时候。那么积分范围最小是什么时候呢？是积分范围为一个狄拉克<em>δ</em>函数的时候。这时，对应的是点光源，或方向光源（Directional Light）。</li>
<li><img src="https://latex.codecogs.com/svg.latex?\Large&space; L_i(p, \omega_i) f_r(p, \omega_i, \omega_o) \cos(\theta_i)"> 比较光滑的时候。这一项和 <img src="https://latex.codecogs.com/svg.latex?\Large&space; \omega_i"> 相关的有光源 <img src="https://latex.codecogs.com/svg.latex?\Large&space; L_i(p, \omega_i) "> 和材质的BRDF项 <img src="https://latex.codecogs.com/svg.latex?\Large&space; f_r(p, \omega_i, \omega_o)"> 。光滑的光照对应着光源范围内趋于固定的辐射值（Constant radiance area lighting），如一般的面光源；而光滑的BRDF对应着物体的材质趋于散射（Diffuse）材质。</li>
</ul>
<h2 id="软阴影算法"><a href="#软阴影算法" class="headerlink" title="软阴影算法"></a>软阴影算法</h2><h3 id="什么是软阴影？"><a href="#什么是软阴影？" class="headerlink" title="什么是软阴影？"></a>什么是软阴影？</h3><p>观察上面的一些带阴影的例子，大家会发现这些阴影的边界非常清晰，阴影区域和非阴影区域有着很明显的分界线。这似乎和我们平时在生活中看到的阴影不太一样，为什么生活中的阴影往往有着模糊的边界呢？</p>
<p>这是因为，上面的例子中，我们使用的光源都是方向光源，它只能产生边界清晰的阴影。</p>
<img style="float: center;" src="/2022/11/29/ShadowAlgorithms/Penumbra2.png" width="600">
<center>图12、本影和半影</center>

<p>图12解释了对于更一般的面光源，阴影边界是过渡的，而不是突变的原因：在图12中，左侧光源是一个面光源，光被遮挡物（一个球）遮挡，而将阴影投射到墙壁上；可以发现，存在一些阴影区域，是完全不能接受到光的，这个区域被称作本影区（Umbra）；同时，也存在一些区域，只能接受到部分光源，这些区域被称作半影区（Penumbra）。在半影区，离本影区越近，接受到的光照就越少——这就是阴影逐渐从暗变为亮的原因。这种由于半影区域的存在而造成的存在过渡的阴影，被称为软阴影（Soft Shadows）。</p>
<h3 id="阴影抗锯齿算法——Percentage-Closer-Filtering"><a href="#阴影抗锯齿算法——Percentage-Closer-Filtering" class="headerlink" title="阴影抗锯齿算法——Percentage Closer Filtering"></a>阴影抗锯齿算法——Percentage Closer Filtering</h3><p>为了在虚拟场景中也能绘制出软阴影，我们需要一些工具。Percentage closer filtering 是人们为了一定程度上解决阴影锯齿的问题而提出的算法——原本我们判断一个位置是否在阴影中，是将这个位置投影到阴影贴图上，根据阴影贴图上像素的深度来进行判断。这个过程一共只做了一次判断，判断的结果是<strong>非零即一</strong>的。为了让锯齿没那么明显，人们不仅仅使用这个位置对应的一个阴影贴图像素，而是看这个像素周围的一圈像素（比如说原像素周围的7x7范围），对这一圈像素都进行深度比较，将<strong>所有比较的结果</strong>进行平均，再作为这个位置的阴影比较结果。这样一来，像素的阴影计算就不再是非零即一的，而变成了在零到一这个区间中的一个值（比如用2x2的像素范围，就能得到 [0, 0.25, 0.50, 0.75, 1.0] 这5种值，分别对应[0个、1个、2个、3个、4个]像素不在阴影中），使得原来的锯齿边缘变得模糊；使用的范围（Filter size）越大，边缘就越模糊，模糊的范围也越大。</p>
<img style="display: inline;" src="/2022/11/29/ShadowAlgorithms/Games202_Mary_HardShadow.png" width="400">
<img style="display: inline;" src="/2022/11/29/ShadowAlgorithms/Games202_Mary_PCF.png" width="400">


<center>(a)平行光计算出来的人物阴影，在地面上存在明显的锯齿 (b) 使用了PCF后得到的人物阴影</center>
<center>图13、PCF的抗锯齿效果(​图源：<a target="_blank" rel="noopener" href="https://sites.cs.ucsb.edu/~lingqi/teaching/games202.html">Games202 </a>Assignment 1)</center>

<p>假设我们渲染的像素是 <em>x</em>，<em>x</em> 对应到阴影贴图的位置是 <em>p</em>，<em>x</em> 对应的可见性为 *V(x)*，则PCF算法的核心思想可以用下面这个公式表示：</p>
<img src="https://latex.codecogs.com/svg.latex?\Large&space; V(x) = \sum_{q\in N(p)}w(p,q) \cdot \chi^{+}[D_{SM}(q)-D_{scene}(x)]">

<p>其中，<em>w(p, q)</em> 是加权函数，<em>N(p)</em> 表示点 <em>p</em> 的邻域（即模糊使用的范围）；<img src="https://latex.codecogs.com/svg.latex?\Large&space; D_{SM}(q)"> 表示 <em>q</em> 点对应的阴影贴图上的深度，<img src="https://latex.codecogs.com/svg.latex?\Large&space; D_{scene}(x)"> 表示 <em>x</em> 对应位置到光源的深度，而<img src="https://latex.codecogs.com/svg.latex?\Large&space; \chi^{+}"> 是下面的这样一个简单函数：</p>
<img src="https://latex.codecogs.com/svg.latex?\Large&space; \chi^{+}(x)=\begin{cases}1, x>0\\ 0, x\leq 0\end{cases}">

<p>题外话：或许有人会奇怪 Percentage Closer Filtering 这个命名是怎么来的——该算法来自于一篇87年的论文【5】, Percentage Closer 指的是在一个场景位置对应的一圈阴影贴图的像素上，像素的深度值比该场景位置的深度值距离光源更近（Closer）的像素数量的百分比（Percentage）；而 Filtering，是指多次比较求平均（或加权平均）的这个操作是一个滤波。</p>
<h3 id="软阴影算法——Percentage-Closer-Soft-Shadows（PCSS）"><a href="#软阴影算法——Percentage-Closer-Soft-Shadows（PCSS）" class="headerlink" title="软阴影算法——Percentage Closer Soft Shadows（PCSS）"></a>软阴影算法——Percentage Closer Soft Shadows（PCSS）</h3><p>从图13(b)可以看到，虽然PCF是用于抗锯齿的，但阴影的边缘看上去已经是软阴影的样子了（有一个阴影过渡带）。但是，整个阴影的边缘的模糊程度是一致（Uniform）的，这和我们在实际生活中看到的不符（图14）。</p>
<img style="float: center;" src="/2022/11/29/ShadowAlgorithms/Sphere_with_soft_shadow.jpg" width="400">
<center>图14，面光源下，球的正确的软阴影</center>

<p>从图12可以看出，如果我们将物体向墙壁移动，半影区的范围将缩小；正如图14所表现的一样：离球越近，阴影的过渡带越短。</p>
<p>这给了我们模拟真实的软阴影一个启发：既然PCF能让阴影变软，不同的滤波范围能产生不同的模糊效果；那么根据阴影离遮挡物（Blocker）的距离从近到远，我们使用对应的滤波范围也从小到大，不就能得到类似图14的效果了么？这正是软阴影算法 Percentage closer soft shadows 【6】的核心思路。</p>
<p>有了这个思路，只需要找到一个估计滤波范围（Filter size）的方法就好了。下面是 PCSS 的做法：</p>
<ul>
<li>遮挡物搜索（Blocker search）：在阴影贴图的一个范围内找到比要渲染的位置（Receiver）的深度更近的深度，即遮挡物（Blocker）的深度，进行平均。搜索的范围取决于光源的大小和该位置到光源的距离。</li>
<li>半影区估计（Penumbra estimation）：利用刚才得到的遮挡物深度，估计半影区域的长度。</li>
<li>滤波：利用估计的半影区范围，来选择合适的滤波范围执行PCF算法。</li>
</ul>
<p>具体的估计方法见图15：</p>
<img style="float: center;" src="/2022/11/29/ShadowAlgorithms/PCSS.png" width="300">
<center>图15、PCSS算法(图源：Percentage-closer soft shadows)</center>

<p>图15中，光源和地板被认为是平行的，<img style="display: inline;" src="https://latex.codecogs.com/svg.latex?\Large&space;w_{Penumbra}"> 即为半影区的长度，<img style="display: inline;" src="https://latex.codecogs.com/svg.latex?\Large&space; w_{Light} "> 是光源的长度。可见，光源长度和半影区的长度分别在两个相似三角形上，因此可以得到半影区的长度的计算公式：</p>
<img src="https://latex.codecogs.com/svg.latex?\Large&space;w_{Penumbra}=\frac{(d_{Receiver} - d_{Blocker}) \cdot w_{Light}}d_{Blocker}">

<p>图16为游戏《消逝的光芒》（<em>Dying Light</em>）中开启了PCSS的截图，可以从电线杆的影子中清晰的看到软阴影的变化。</p>
<img style="float: center;" src="/2022/11/29/ShadowAlgorithms/dying-light-pcss-001-on.png" width="800">

<p>​                                                  图源：<a target="_blank" rel="noopener" href="https://shadowalgorithms.nvidia.com/geforce-com/international/comparisons/dying-light/dying-light-nvidia-pcss-interactive-comparison-001-pcss-on-vs-off.html">Nvidia 图片库</a></p>
<center>图16、游戏《消逝的光芒》截图</center>

<h2 id="方差阴影贴图（Variance-Shadow-Maps）"><a href="#方差阴影贴图（Variance-Shadow-Maps）" class="headerlink" title="方差阴影贴图（Variance Shadow Maps）"></a>方差阴影贴图（Variance Shadow Maps）</h2><h3 id="PCF的缺陷"><a href="#PCF的缺陷" class="headerlink" title="PCF的缺陷"></a>PCF的缺陷</h3><p>PCF在每一次进行阴影计算时，是将阴影贴图的一个范围的所有像素的深度和一个阴影值 <em>t</em> 进行比较，再将比较的结果进行平均；这个平均后的结果，其实就是这个范围内，深度值<strong>大于</strong> <em>t</em> 的像素的比例。正是为了得到这个比例，PCF查询（或采样）了这个范围内的所有像素，这种采样本身是非常耗时的；然而，为了能有好的效果，采样的范围却不能太小。能不能不查询（或采样）这个范围的像素呢？同时，显卡本身提供了内置的Mipmap以及各向异性滤波方法，用于对贴图进行模糊。那么，有没有办法让阴影的计算也能用上这种显卡内置的滤波能力呢？</p>
<h3 id="方差阴影贴图的算法原理"><a href="#方差阴影贴图的算法原理" class="headerlink" title="方差阴影贴图的算法原理"></a>方差阴影贴图的算法原理</h3><p>方差阴影贴图算法[7]提出了一个大胆的想法：假设知道了这个范围内所有像素的深度的分布，那么我们就能很快的得到深度值大于 <em>t</em> 的像素的比例，从而不需要进行更多的采样。</p>
<p>那么深度的分布要怎么得到呢？方差阴影贴图找到了切比雪夫不等式（Chebyshev’s Inequality）：</p>
<img src="https://latex.codecogs.com/svg.latex?\Large&space; P(x\geq t) \leq \frac{\sigma^2}{\sigma^2 + (t - \mu)^2}, \quad\text{for }t > \mu">

<p>其中，<img src="https://latex.codecogs.com/svg.latex?\Large&space; \sigma"> 是分布的标准差，<img src="https://latex.codecogs.com/svg.latex?\Large&space; \mu"> 是分布的均值，<img src="https://latex.codecogs.com/svg.latex?\Large&space; P(x\geq t) "> 是大于 <em>t</em> 的值的比例。这个不等式告诉我们，如果我们知道了一个分布的均值和方差，那么对于大于均值的 <em>t</em>，我们可以立刻知道分布中比 <em>t</em> 大的值的最大比例。若直接用这个最大比例来估计阴影贴图的深度比较结果，我们不就可以立刻知道，对于一个位置，它是不是处于阴影之中了么？而对于 <img src="https://latex.codecogs.com/svg.latex?\Large&space; t \leq \mu"> 的情况，方差阴影贴图算法直接认为这个位置是处于非阴影中的。</p>
<p>这样，我们就剩下了一个问题，要怎么方便的得到一个范围内的均值和方差？</p>
<p>均值好办，这可以用 Mipmaps 或者是求和面积表（Summed-area table）来进行快速计算。那么方差呢？且看下面的式子：</p>
<img src="https://latex.codecogs.com/svg.latex?\Large&space;\sigma^2 = E(x^2) - E(x)^2">

<p>这个式子告诉我们，方差的计算可以用平方的均值减去均值的平方来得到。所以当计算阴影贴图中各个像素的深度的时候，同时计算深度的平方并保存下来，不就可以快速得到深度的平方的期望了么？如果深度占用了深度贴图的一个通道，深度的平方可以存放在未使用的其他通道，所以深度的平方的计算和保存，都可以在计算阴影贴图时很方便地“顺手”完成。同时，由于 <img src="https://latex.codecogs.com/svg.latex?\Large&space;E(x^2)"> 和 <img src="https://latex.codecogs.com/svg.latex?\Large&space;E(x)"> 是可以被插值的，所以显卡内置的滤波技术——Mipmapping和各项异性滤波——可以被用来降低阴影贴图的锯齿。</p>
<img style="float: center;" src="/2022/11/29/ShadowAlgorithms/VSM.png" width="600">
<center>图源：Variance Shadow Maps</center>
<center>图17、VSM算法效果比较。从左到右分别为各个算法的效果：(a)标准的阴影映射；(b)5x5的PCF；(c)5x5的PCF，并在深度比较结果上进行2x2的双线性插值(d)VSM</center>

<p>图17为算法原论文中作者得到的结果：在GeForce 6800GT上，图17(d)中的VSM和图17(c)的效果类似，效率却是至少3倍以上。</p>
<h3 id="VSM-的问题——以及MSM、CSM、ESM"><a href="#VSM-的问题——以及MSM、CSM、ESM" class="headerlink" title="VSM 的问题——以及MSM、CSM、ESM"></a>VSM 的问题——以及MSM、CSM、ESM</h3><p>当然了，VSM也有一些问题：将深度的分布都用均值和方差描述了，在方差比较大的时候，就容易出现原本不该有的非阴影部分（Light leaking）。</p>
<img style="float: center;" src="/2022/11/29/ShadowAlgorithms/vsm_light_bleeding.png" width="400">

<p>​<center>图源：<a target="_blank" rel="noopener" href="https://pixelstoomany.wordpress.com/category/shadows/light-bleeding/">pixelstoomany</a></center></p>
<center>图18、VSM的 Light bleeding 现象（水壶盖子周边的阴影被错误的计算，就像漏光一样）</center>

<p>这种 Light bleeding 现象，本质上还是使用切比雪夫不等式来对深度分布的估计过于简单。在数学中，矩（Moment）可以被用来描述随机变量的分布，比如随机变量的期望就是一阶矩，其方差就是二阶矩。在切比雪夫不等式中，我们只使用了一阶矩<img src="https://latex.codecogs.com/svg.latex?\Large&space;E(x)">和二阶矩<img src="https://latex.codecogs.com/svg.latex?\Large&space;\sigma^2 ">；就像泰勒展开的项数越多近似越准确一样，用越多不同阶的矩去近似一个分布，就能得到越准确的结果，这也就是<strong>矩阴影映射算法（Moment Shadow Mapping）</strong>[8]的思路。在使用前四阶矩的情况下，矩阴影映射算法可以得到非常不错的效果（图19）。</p>
<p><img style="display: inline;" src="/2022/11/29/ShadowAlgorithms/MSM_vsm.png" width="400"><img style="display: inline;" src="/2022/11/29/ShadowAlgorithms/MSM_msm.png" width="410"></p>
<center>图19、阴影结果比较。左图：VSM；右图：MSM(图源：Moment Shadow Mapping​)</center>

<p><strong>卷积阴影贴图（Convolution Shadow Maps）</strong>[9]以及<strong>指数阴影贴图（Exponential Shadow Maps）</strong>[10]用了不同的思路去解决阴影映射的走样问题：相对于VSM的估计深度的分布，它们选择了去近似深度测试函数。其中，卷积阴影贴图使用了傅里叶级数来进行近似，这种方法不会产生漏光现象，并且可以得到很好的阴影效果，代价是需要将傅里叶级数的系数存在新的贴图中，大大增加了存储量；指数阴影贴图使用指数函数了来进行近似深度测试函数，避免了大量的存储开销，不过在阴影接收物的边界存在阴影不稳定的问题。</p>
<p><img style="display: inline;" src="/2022/11/29/ShadowAlgorithms/ConvSM.png" width="500"><img style="display: inline;" src="/2022/11/29/ShadowAlgorithms/ESM.png" width="380"></p>
<center>图20、左图：卷积阴影贴图结果(7x7 blur and mip-mapping)；右图：指数阴影贴图结果（using 5×5 Gauss filtering）</center>

<h3 id="方差软阴影映射算法（Variance-Soft-Shadow-Mapping）"><a href="#方差软阴影映射算法（Variance-Soft-Shadow-Mapping）" class="headerlink" title="方差软阴影映射算法（Variance Soft Shadow Mapping）"></a>方差软阴影映射算法（Variance Soft Shadow Mapping）</h3><p>方差阴影贴图算法解决了快速近似PCF的问题，如果要计算软阴影，还需要知道遮挡物搜索（Blocker search）要怎么做。</p>
<p>遮挡物搜索，其实就是在阴影贴图的一个范围内找到比一个值 <em>t</em> 小的像素，以这些像素的深度的平均值来作为遮挡物的深度。</p>
<img style="float: center;" src="/2022/11/29/ShadowAlgorithms/number_area.png" width="180">

<center>图21、一个5x5大小的深度贴图的例子(图源：<a target="_blank" rel="noopener" href="https://sites.cs.ucsb.edu/~lingqi/teaching/games202.html">Games202​</a>)</center>

<p>比如在图21中，假设我们的要查询的深度为7，那么深度比7更小的（蓝色的数字）就是遮挡物，我们记它们的平均深度为<img style="display: inline;" src="https://latex.codecogs.com/svg.latex?\Large&space;z_{occ}">；而红色的部分，我们记它们的平均深度为非遮挡物深度<img style="display: inline;" src="https://latex.codecogs.com/svg.latex?\Large&space;z_{unocc}">。</p>
<p>对于一个一共有 <em>N</em> 个点的范围，加入比 <em>t</em> 深度小的点共有 <img style="display: inline;" src="https://latex.codecogs.com/svg.latex?\Large&space;N_1">个，深度大于等于 <em>t</em> 的点共有 <img style="display: inline;" src="https://latex.codecogs.com/svg.latex?\Large&space;N_2">个，那么有下面这样的等式：</p>
<img src="https://latex.codecogs.com/svg.latex?\Large&space;\frac{N_1}{N} z_{occ} + \frac{N_2}{N}z_{unocc} = z_{avg} ">

<p>其中<img style="display: inline;" src="https://latex.codecogs.com/svg.latex?\Large&space;z_{avg} ">是深度的平均值。在上面的等式中，只有<img style="display: inline;" src="https://latex.codecogs.com/svg.latex?\Large&space;z_{avg} ">和 <em>N</em> 是我们知道的，要怎么得到<img style="display: inline;" src="https://latex.codecogs.com/svg.latex?\Large&space;z_{occ}">呢？</p>
<p>首先看<img style="display: inline;" src="https://latex.codecogs.com/svg.latex?\Large&space; \frac{N_2}{N} ">，这是深度大于等于 <em>t</em> 的点的比例，这不就是我们刚刚在切比雪夫不等式中的<img style="display: inline;" src="https://latex.codecogs.com/svg.latex?\Large&space; P(x\geq t) ">么？而如果<img style="display: inline;" src="https://latex.codecogs.com/svg.latex?\Large&space; \frac{N_2}{N} ">已经知道了，<img style="display: inline;" src="https://latex.codecogs.com/svg.latex?\Large&space; \frac{N_1}{N} ">也就自然知道了（<img style="display: inline;" src="https://latex.codecogs.com/svg.latex?\Large&space; 1 - \frac{N_2}{N} ">）。接下来，只要再做一个大胆的假设：<img style="display: inline;" src="https://latex.codecogs.com/svg.latex?\Large&space;z_{unocc}=t">，那么<img style="display: inline;" src="https://latex.codecogs.com/svg.latex?\Large&space;z_{occ}">就可以很方便地计算出来了！</p>
<p><img style="display: inline;" src="https://latex.codecogs.com/svg.latex?\Large&space;z_{unocc}=t"> 这个近似，相当于是说阴影的接收点处于一个和光源平行的平面，所以当这个条件不满足的时候，这个近似就不够准确了。虽然如此，在一般情况下，VSSM都可以得到很好的结果（图22）</p>
<img style="float: center;" src="/2022/11/29/ShadowAlgorithms/VSSM.jpg" width="500">

<center>图22、VSSM算法得到的软阴影(​图源: <a target="_blank" rel="noopener" href="https://developer.nvidia.com/gpugems/gpugems3/part-ii-light-and-shadows/chapter-8-summed-area-variance-shadow-maps">GPUGems3 - Chapter 8</a>)</center>

<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本文的内容框架来自于一个非常棒的实时渲染在线课程 <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1YK4y1T7yY?from=search&seid=11430567094229083133">Games 202</a> 的第三讲及第四讲，十分推荐。<br>文章中用到的参考链接及参考文献已被列在了文章末尾。</p>
<p><strong>参考链接</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1YK4y1T7yY?from=search&seid=11430567094229083133">Games 202</a><br><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE">维基百科的Shadow mapping</a><br><a target="_blank" rel="noopener" href="https://developer.nvidia.com/gpugems/gpugems/part-ii-lighting-and-shadows/chapter-11-shadow-map-antialiasing">GPUGems chapter 11-shadow-map-antialiasing</a><br><a target="_blank" rel="noopener" href="https://developer.nvidia.com/gpugems/gpugems3/part-ii-light-and-shadows/chapter-10-parallel-split-shadow-maps-programmable-gpus">GPUGems3 chapter-10-parallel-split-shadow-maps-programmable-gpus</a><br><a target="_blank" rel="noopener" href="https://developer.nvidia.com/gpugems/gpugems3/part-ii-light-and-shadows/chapter-8-summed-area-variance-shadow-maps">GPUGems3 - Chapter 8</a><br><a target="_blank" rel="noopener" href="https://learnopengl.com/Advanced-Lighting/Shadows/Shadow-Mapping">https://learnopengl.com/Advanced-Lighting/Shadows/Shadow-Mapping</a></p>
<p><strong>参考文献</strong></p>
<p>[1] Williams L. Casting curved shadows on curved surfaces[C]&#x2F;&#x2F;Proceedings of the 5th annual conference on Computer graphics and interactive techniques. 1978: 270-274.<br>[2] Stamminger M, Drettakis G. Perspective shadow maps[C]&#x2F;&#x2F;Proceedings of the 29th annual conference on Computer graphics and interactive techniques. 2002: 557-562.<br>[3] Fernando R, Fernandez S, Bala K, et al. Adaptive shadow maps[C]&#x2F;&#x2F;Proceedings of the 28th annual conference on Computer graphics and interactive techniques. 2001: 387-390.<br>[4] Zhang F, Sun H, Xu L, et al. Parallel-split shadow maps for large-scale virtual environments[C]&#x2F;&#x2F;Proceedings of the 2006 ACM international conference on Virtual reality continuum and its applications. 2006: 311-318.<br>[5] Reeves W T, Salesin D H, Cook R L. Rendering antialiased shadows with depth maps[C]&#x2F;&#x2F;Proceedings of the 14th annual conference on Computer graphics and interactive techniques. 1987: 283-291.<br>[6] Fernando R. Percentage-closer soft shadows[M]&#x2F;&#x2F;ACM SIGGRAPH 2005 Sketches. 2005: 35-es.<br>[7] Donnelly W, Lauritzen A. Variance shadow maps[C]&#x2F;&#x2F;Proceedings of the 2006 symposium on Interactive 3D graphics and games. 2006: 161-165.<br>[8] Peters C, Klein R. Moment shadow mapping[C]&#x2F;&#x2F;Proceedings of the 19th Symposium on Interactive 3D Graphics and Games. 2015: 7-14.<br>[9] Annen T, Mertens T, Bekaert P, et al. Convolution Shadow Maps[J]. Rendering Techniques, 2007, 18: 51-60.<br>[10] Annen T, Mertens T, Seidel H P, et al. Exponential shadow maps[C]&#x2F;&#x2F;Graphics Interface. ACM Press, 2008: 155-161.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/11/Universal-Reference/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wizlyk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wizlyk">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/08/11/Universal-Reference/" class="post-title-link" itemprop="url">Universal Reference in C++11</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-08-11 10:15:21" itemprop="dateCreated datePublished" datetime="2019-08-11T10:15:21+08:00">2019-08-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-29 21:20:00" itemprop="dateModified" datetime="2022-11-29T21:20:00+08:00">2022-11-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong><em>T&amp;&amp; Doesn’t Always Mean “Rvalue Reference”</em>  -Scott Meyers</strong></p>
<p><a target="_blank" rel="noopener" href="https://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers">https://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers</a></p>
<p>有时间我再做一个翻译和理解。</p>
<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>2022-11-29: 找回博客才发现这个坑，就放这里吧。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/11/EMC-notes-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wizlyk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wizlyk">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/08/11/EMC-notes-3/" class="post-title-link" itemprop="url">Moving to Modern C++ - 《Effective Modern C++》阅读笔记（三）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-08-11 09:50:15" itemprop="dateCreated datePublished" datetime="2019-08-11T09:50:15+08:00">2019-08-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-29 20:38:11" itemprop="dateModified" datetime="2022-11-29T20:38:11+08:00">2022-11-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>本文所有内容参考于 《Effective Modern C++》（Scott Meyers）一书，仅供个人学习</code></p>
<h1 id="Moving-to-Modern-C"><a href="#Moving-to-Modern-C" class="headerlink" title="Moving to Modern C++"></a>Moving to Modern C++</h1><h2 id="Item-7-辨别生成对象时-和-的不同"><a href="#Item-7-辨别生成对象时-和-的不同" class="headerlink" title="Item 7:辨别生成对象时()和{}的不同"></a>Item 7:辨别生成对象时()和{}的不同</h2><p>当一个类没有以 initializer_list 为参数的构造函数时，使用()和{}并无二致：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Widget</span>(<span class="type">int</span> i, <span class="type">bool</span> b); <span class="comment">// ctors not declaring</span></span><br><span class="line">  <span class="built_in">Widget</span>(<span class="type">int</span> i, <span class="type">double</span> d); <span class="comment">// std::initializer_list params</span></span><br><span class="line">…</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Widget <span class="title">w1</span><span class="params">(<span class="number">10</span>, <span class="literal">true</span>)</span></span>; <span class="comment">// calls first ctor</span></span><br><span class="line">Widget w2&#123;<span class="number">10</span>, <span class="literal">true</span>&#125;; <span class="comment">// also calls first ctor</span></span><br><span class="line"><span class="function">Widget <span class="title">w3</span><span class="params">(<span class="number">10</span>, <span class="number">5.0</span>)</span></span>; <span class="comment">// calls second ctor</span></span><br><span class="line">Widget w4&#123;<span class="number">10</span>, <span class="number">5.0</span>&#125;; <span class="comment">// also calls second ctor</span></span><br></pre></td></tr></table></figure>

<p>但若有了以 initializer_list 为参数的构造函数，使用{}会优先匹配对应的构造函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Widget</span>(<span class="type">int</span> i, <span class="type">bool</span> b); <span class="comment">// as before</span></span><br><span class="line">  <span class="built_in">Widget</span>(<span class="type">int</span> i, <span class="type">double</span> d); <span class="comment">// as before</span></span><br><span class="line">  <span class="built_in">Widget</span>(std::initializer_list&lt;<span class="type">long</span> <span class="type">double</span>&gt; il); <span class="comment">// added</span></span><br><span class="line">…</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Widget <span class="title">w1</span><span class="params">(<span class="number">10</span>, <span class="literal">true</span>)</span></span>; <span class="comment">// uses parens and, as before,</span></span><br><span class="line">                     <span class="comment">// calls first ctor</span></span><br><span class="line">Widget w2&#123;<span class="number">10</span>, <span class="literal">true</span>&#125;; <span class="comment">// uses braces, but now calls</span></span><br><span class="line">                     <span class="comment">// std::initializer_list ctor</span></span><br><span class="line">                     <span class="comment">// (10 and true convert to long double)</span></span><br><span class="line"><span class="function">Widget <span class="title">w3</span><span class="params">(<span class="number">10</span>, <span class="number">5.0</span>)</span></span>; <span class="comment">// uses parens and, as before,</span></span><br><span class="line">                    <span class="comment">// calls second ctor</span></span><br><span class="line">Widget w4&#123;<span class="number">10</span>, <span class="number">5.0</span>&#125;; <span class="comment">// uses braces, but now calls</span></span><br><span class="line">                    <span class="comment">// std::initializer_list ctor</span></span><br><span class="line">                    <span class="comment">// (10 and 5.0 convert to long double)</span></span><br></pre></td></tr></table></figure>

<p>这里可以看到，true 和 10 等都被隐式类型转换成了 long double，可见 initializer_list 的构造函数的优先级非常高。<br>它的优先级甚至高于了移动构造函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Widget</span>(<span class="type">int</span> i, <span class="type">bool</span> b); <span class="comment">// as before</span></span><br><span class="line">	<span class="built_in">Widget</span>(<span class="type">int</span> i, <span class="type">double</span> d); <span class="comment">// as before</span></span><br><span class="line">	<span class="built_in">Widget</span>(std::initializer_list&lt;<span class="type">long</span> <span class="type">double</span>&gt; il); <span class="comment">// as before</span></span><br><span class="line">	<span class="function"><span class="keyword">operator</span> <span class="title">float</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// convert</span></span><br><span class="line">	… <span class="comment">// to float</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Widget <span class="title">w5</span><span class="params">(w4)</span></span>; <span class="comment">// uses parens, calls copy ctor</span></span><br><span class="line">Widget w6&#123;w4&#125;; <span class="comment">// uses braces, calls</span></span><br><span class="line">               <span class="comment">// std::initializer_list ctor</span></span><br><span class="line">               <span class="comment">// (w4 converts to float, and float</span></span><br><span class="line">               <span class="comment">// converts to long double)</span></span><br><span class="line"><span class="function">Widget <span class="title">w7</span><span class="params">(std::move(w4))</span></span>; <span class="comment">// uses parens, calls move ctor</span></span><br><span class="line">Widget w8&#123;std::<span class="built_in">move</span>(w4)&#125;; <span class="comment">// uses braces, calls</span></span><br><span class="line">                          <span class="comment">// std::initializer_list ctor</span></span><br><span class="line">                          <span class="comment">// (for same reason as w6)</span></span><br></pre></td></tr></table></figure>

<p><strong>待编辑：说实话，这里并不太懂，w4会直接使用operator()?</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Widget</span>(<span class="type">int</span> i, <span class="type">bool</span> b); <span class="comment">// as before</span></span><br><span class="line">  <span class="built_in">Widget</span>(<span class="type">int</span> i, <span class="type">double</span> d); <span class="comment">// as before</span></span><br><span class="line">  <span class="built_in">Widget</span>(std::initializer_list&lt;<span class="type">bool</span>&gt; il); <span class="comment">// element type is</span></span><br><span class="line">                                          <span class="comment">// now bool</span></span><br><span class="line">  … <span class="comment">// no implicit</span></span><br><span class="line">&#125;; <span class="comment">// conversion funcs</span></span><br><span class="line"></span><br><span class="line">Widget w&#123;<span class="number">10</span>, <span class="number">5.0</span>&#125;; <span class="comment">// error! requires narrowing conversions</span></span><br></pre></td></tr></table></figure>

<p>从上面这例可以看出，编译器非常倾向于使用 std::initializer_list 的构造函数，从而使得正确匹配参数的构造函数并不会被使用。另外还有个小知识点：{}初始器中，缩小范围的隐式类型转换会报错。<br>只有在无法进行类型转换的情况下，编译器才会考虑其他的构造函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Widget</span>(<span class="type">int</span> i, <span class="type">bool</span> b); <span class="comment">// as before</span></span><br><span class="line">  <span class="built_in">Widget</span>(<span class="type">int</span> i, <span class="type">double</span> d); <span class="comment">// as before</span></span><br><span class="line"><span class="comment">// std::initializer_list element type is now std::string</span></span><br><span class="line">  <span class="built_in">Widget</span>(std::initializer_list&lt;std::string&gt; il);</span><br><span class="line">  … <span class="comment">// no implicit</span></span><br><span class="line">&#125;; <span class="comment">// conversion funcs</span></span><br><span class="line"></span><br><span class="line"><span class="function">Widget <span class="title">w1</span><span class="params">(<span class="number">10</span>, <span class="literal">true</span>)</span></span>; <span class="comment">// uses parens, still calls first ctor</span></span><br><span class="line">Widget w2&#123;<span class="number">10</span>, <span class="literal">true</span>&#125;; <span class="comment">// uses braces, now calls first ctor</span></span><br><span class="line"><span class="function">Widget <span class="title">w3</span><span class="params">(<span class="number">10</span>, <span class="number">5.0</span>)</span></span>; <span class="comment">// uses parens, still calls second ctor</span></span><br><span class="line">Widget w4&#123;<span class="number">10</span>, <span class="number">5.0</span>&#125;; <span class="comment">// uses braces, now calls second ctor</span></span><br></pre></td></tr></table></figure>

<p>那么，当初始化是使用空的 {} 会怎么样呢？是空的 initializer_list 还是调用默认构造函数？结论是<strong>调用默认构造函数</strong>。当然了，如果你想使用空的 ()，那会变成调用一个对应名字的函数了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Widget</span>(); <span class="comment">// default ctor</span></span><br><span class="line">  <span class="built_in">Widget</span>(std::initializer_list&lt;<span class="type">int</span>&gt; il); <span class="comment">// std::initializer_list ctor</span></span><br><span class="line">  … <span class="comment">// no implicit</span></span><br><span class="line">&#125;; <span class="comment">// conversion funcs</span></span><br><span class="line"></span><br><span class="line">Widget w1; <span class="comment">// calls default ctor</span></span><br><span class="line">Widget w2&#123;&#125;; <span class="comment">// also calls default ctor</span></span><br><span class="line"><span class="function">Widget <span class="title">w3</span><span class="params">()</span></span>; <span class="comment">// most vexing parse! declares a function!</span></span><br></pre></td></tr></table></figure>

<p>如果真的想调用空的 initializer_list，需要两重括号：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">w4</span><span class="params">(&#123;&#125;)</span></span>; <span class="comment">// calls std::initializer_list ctor</span></span><br><span class="line">               <span class="comment">// with empty list</span></span><br><span class="line">Widget w5&#123;&#123;&#125;&#125;; <span class="comment">// ditto</span></span><br></pre></td></tr></table></figure>

<p>对于模板编写者来说，若想自己定义对于 () 中参数的反应，可以像如下代码这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="comment">// type of object to create</span></span><br><span class="line">	<span class="keyword">typename</span>... Ts&gt; <span class="comment">// types of arguments to use</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomeWork</span><span class="params">(Ts&amp;&amp;... params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">T <span class="title">localObject1</span><span class="params">(std::forward&lt;Ts&gt;(params)...)</span></span>; <span class="comment">// using parens  </span></span><br><span class="line">  <span class="comment">// 或者像下面这样</span></span><br><span class="line">  T localObject2&#123;std::forward&lt;Ts&gt;(params)...&#125;; <span class="comment">// using braces</span></span><br><span class="line">…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，对于下面的代码，localObject1 会是一个由10个元素组成的 vector，而 localObject2 是由2个元素组成的 vector。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doSomeWork&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;(<span class="number">10</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<p><strong>Things to Remember</strong></p>
<ul>
<li>Braced initialization is the most widely usable initialization syntax, it prevents narrowing conversions, and it’s immune to C++’s most vexing parse. </li>
<li>During constructor overload resolution, braced initializers are matched to std::initializer_list parameters if at all possible, even if other constructors offer seemingly better matches.</li>
<li>An example of where the choice between parentheses and braces can make a significant difference is creating a std::vector&lt;numeric type&gt; with two arguments.</li>
<li>Choosing between parentheses and braces for object creation inside templates can be challenging.</li>
</ul>
<h2 id="Item-8-多用-nullptr-代替-0-和-null"><a href="#Item-8-多用-nullptr-代替-0-和-null" class="headerlink" title="Item 8:多用 nullptr 代替 0 和 null"></a>Item 8:多用 nullptr 代替 0 和 null</h2><p>当 C++ 发现一个需要用指针的地方出现了0时，它通常会把0看作是一个空指针。然而，C++主要的原则还是将0看作是一个int。NULL 也类似，编译允许在一些情况下将 NULL 当成一个整数（如 long）。<br>在 C++98 中，使用0和 NULL 的重载可能会有一些意外：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>)</span></span>; <span class="comment">// three overloads of f</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">bool</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">void</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(<span class="number">0</span>); <span class="comment">// calls f(int), not f(void*)</span></span><br><span class="line"><span class="built_in">f</span>(<span class="literal">NULL</span>); <span class="comment">// might not compile, but typically calls</span></span><br><span class="line">         <span class="comment">// f(int). Never calls f(void*)</span></span><br></pre></td></tr></table></figure>

<p>如果 NULL 的定义是 0L，那么编译的结果可能是模糊的，因为从 long 到 int 和从 0L 到 void* 是同样优先的。<br>所以，之所以推荐使用 nullptr，就是因为 nullptr 没有 int 类型，从而可以把它看成是一个可以代表所有类型的空指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">f</span>(<span class="literal">nullptr</span>); <span class="comment">// calls f(void*) overload</span></span><br></pre></td></tr></table></figure>

<p>在 cppreference 网站上找到个有意思的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F, <span class="keyword">class</span> A&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Fwd</span><span class="params">(F f, A a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(<span class="type">int</span>* i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Function g called\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">g</span>(<span class="literal">NULL</span>);           <span class="comment">// Fine</span></span><br><span class="line">    <span class="built_in">g</span>(<span class="number">0</span>);              <span class="comment">// Fine</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">Fwd</span>(g, <span class="literal">nullptr</span>);   <span class="comment">// Fine</span></span><br><span class="line"><span class="comment">//  Fwd(g, NULL);  // ERROR: No function g(int)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子有意思在哪呢？可以知道，如果单纯的调用函数 g:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">g</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">g</span>(<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p>是不会出错的，0 和 NULL 都被转换成了空指针；然而模板中 0 和 NULL 都被推断为 int 类型，从而导致了错误。这种错误排查起来可是很令人头疼的。</p>
<p><strong>Things to Remember</strong></p>
<ul>
<li>Prefer nullptr to 0 and NULL.</li>
<li>Avoid overloading on integral and pointer types.</li>
</ul>
<h2 id="Item-9-多用-alias-declarations-而不是-typedefs"><a href="#Item-9-多用-alias-declarations-而不是-typedefs" class="headerlink" title="Item 9:多用 alias declarations 而不是 typedefs"></a>Item 9:多用 alias declarations 而不是 typedefs</h2><p>当定义较长且常用时，C++11 以前一般用 typedef 来简化代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::unique_ptr&lt;std::unordered_map&lt;std::string, std::string&gt;&gt; UPtrMapSS;</span><br></pre></td></tr></table></figure>

<p>C++11 提供了 alias declarations：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UPtrMapSS = std::unique_ptr&lt;std::unordered_map&lt;std::string, std::string&gt;&gt;;</span><br></pre></td></tr></table></figure>

<p>他们俩提供了相同的作用。那么为什么还提倡使用 alias declarations 呢？首先 alias declarations 在涉及到函数指针时更直观：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FP is a synonym for a pointer to a function taking an int and</span></span><br><span class="line"><span class="comment">// a const std::string&amp; and returning nothing</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*FP)</span><span class="params">(<span class="type">int</span>, <span class="type">const</span> std::string&amp;)</span></span>; <span class="comment">// typedef</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// same meaning as above</span></span><br><span class="line"><span class="keyword">using</span> FP = <span class="built_in">void</span> (*)(<span class="type">int</span>, <span class="type">const</span> std::string&amp;); <span class="comment">// alias declaration</span></span><br></pre></td></tr></table></figure>

<p>其次， alias declarations 可以模板化，而 typedef 不能：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">// MyAllocList&lt;T&gt;</span></span><br><span class="line"><span class="keyword">using</span> MyAllocList = std::list&lt;T, MyAlloc&lt;T&gt;&gt;; <span class="comment">// is synonym for std::list&lt;T, MyAlloc&lt;T&gt;&gt;</span></span><br><span class="line">MyAllocList&lt;Widget&gt; lw; <span class="comment">// client code</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">// MyAllocList&lt;T&gt;::type</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyAllocList</span> &#123;                     <span class="comment">// is synonym for</span></span><br><span class="line">  <span class="keyword">typedef</span> std::list&lt;T, MyAlloc&lt;T&gt;&gt; type; <span class="comment">// std::list&lt;T,</span></span><br><span class="line">&#125;;                                       <span class="comment">// MyAlloc&lt;T&gt;&gt;</span></span><br><span class="line">MyAllocList&lt;Widget&gt;::type lw; <span class="comment">// client code</span></span><br></pre></td></tr></table></figure>

<p>当使用 typedef 时，如果我们想用 MyAllocList 在模板里创建一个对象，需要使用 typename:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123; <span class="comment">// Widget&lt;T&gt; contains</span></span><br><span class="line"><span class="keyword">private</span>: <span class="comment">// a MyAllocList&lt;T&gt;</span></span><br><span class="line">  <span class="keyword">typename</span> MyAllocList&lt;T&gt;::type list; <span class="comment">// as a data member</span></span><br><span class="line">…</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这里，MyAllocList&lt;T&gt;::type 是一个依赖于参数T的依赖类型(dependent type)，而C++要求依赖类型必须使用 typename。<br>而若是使用 alias template，代码会明快很多：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> MyAllocList = std::list&lt;T, MyAlloc&lt;T&gt;&gt;; <span class="comment">// as before</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  MyAllocList&lt;T&gt; list; <span class="comment">// no &quot;typename&quot;,</span></span><br><span class="line">… <span class="comment">// no &quot;::type&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>之所以会这样，是因为使用 alias template 的 MyAllocList<T> 必定是一个类型，而使用 typedef 的 MyAllocList<T>::type 并不一定是类型，所以后者需要使用 typename 来保证编译不会出错。作者在这顺带吐槽了一下：“That sounds<br>crazy, but don’t blame compilers for this possibility. It’s the humans who have been<br>known to produce such code.”</T></T></p>
<p>在 C++11 中，有个叫 type_traits 的标准库，提供了允许用户得到不同的参数类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::remove_const&lt;T&gt;::type <span class="comment">// yields T from const T</span></span><br><span class="line">std::remove_reference&lt;T&gt;::type <span class="comment">// yields T from T&amp; and T&amp;&amp;</span></span><br><span class="line">std::add_lvalue_reference&lt;T&gt;::type <span class="comment">// yields T&amp; from T</span></span><br></pre></td></tr></table></figure>

<p>注意这里都使用了 ::type。没错，这是 C++11 的，之所以不用 alias template 是由于一些历史原因。在 C++14 中，alias template 的 type_traits 也被加上了:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::remove_const&lt;T&gt;::type <span class="comment">// C++11: const T → T</span></span><br><span class="line">std::<span class="type">remove_const_t</span>&lt;T&gt; <span class="comment">// C++14 equivalent</span></span><br><span class="line">std::remove_reference&lt;T&gt;::type <span class="comment">// C++11: T&amp;/T&amp;&amp; → T</span></span><br><span class="line">std::<span class="type">remove_reference_t</span>&lt;T&gt; <span class="comment">// C++14 equivalent</span></span><br><span class="line">std::add_lvalue_reference&lt;T&gt;::type <span class="comment">// C++11: T → T&amp;</span></span><br><span class="line">std::<span class="type">add_lvalue_reference_t</span>&lt;T&gt; <span class="comment">// C++14 equivalent</span></span><br></pre></td></tr></table></figure>

<p>“The C++11 constructs remain valid in C++14, but I don’t know why you’d want to use them.”</p>
<p>当然了，如果你想自己实现 C++14 类似的 alias templates，可以像下面这样做：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="type">remove_const_t</span> = <span class="keyword">typename</span> remove_const&lt;T&gt;::type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="type">remove_reference_t</span> = <span class="keyword">typename</span> remove_reference&lt;T&gt;::type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="type">add_lvalue_reference_t</span> = <span class="keyword">typename</span> add_lvalue_reference&lt;T&gt;::type;</span><br></pre></td></tr></table></figure>

<p><strong>Things to Remember</strong></p>
<ul>
<li>typedefs don’t support templatization, but alias declarations do.</li>
<li>Alias templates avoid the “::type” suffix and, in templates, the “typename” prefix often required to refer to typedefs.</li>
<li>C++14 offers alias templates for all the C++11 type traits transformations.</li>
</ul>
<h2 id="Item-10-多用-scoped-enums-而不是-unscoped-enums"><a href="#Item-10-多用-scoped-enums-而不是-unscoped-enums" class="headerlink" title="Item 10:多用 scoped enums 而不是 unscoped enums"></a>Item 10:多用 scoped enums 而不是 unscoped enums</h2><p>在 C++98 有 enum 类型，它的用法是这样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123; black, white, red &#125;;</span><br></pre></td></tr></table></figure>

<p>然而这样使用会有隐患，比如若在这个定义的下面加上这样一句，就会出错：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> white = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>这是由于 enum 里面的变量是包括在整个和 Color 一样的参数空间里的，即 Color 在哪有效，这些 black 等就在哪有效。 这样的范围没有被限制的 enums 被称作 unscoped enums。 为了避免这种隐患，C++11 引入了 scoped enums:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span> &#123; black, white, red &#125;; <span class="comment">// black, white, red</span></span><br><span class="line">                                        <span class="comment">// are scoped to Color</span></span><br><span class="line"><span class="keyword">auto</span> white = <span class="literal">false</span>; <span class="comment">// fine, no other &quot;white&quot; in scope</span></span><br><span class="line">Color c = white; <span class="comment">// error! no enumerator named</span></span><br><span class="line">                 <span class="comment">// &quot;white&quot; is in this scope</span></span><br><span class="line">Color c = Color::white; <span class="comment">// fine</span></span><br><span class="line"><span class="keyword">auto</span> c = Color::white; <span class="comment">// also fine (and in accord</span></span><br><span class="line">                       <span class="comment">// with Item 5&#x27;s advice)</span></span><br></pre></td></tr></table></figure>

<p>Scoped enums 也被称为 enum classes。<br>除了作用范围以外，unscoped enums 和 scoped enums 还有类型转换上的差距：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123; black, white, red &#125;; <span class="comment">// unscoped enum</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">size_t</span>&gt; <span class="title">primeFactors</span><span class="params">(<span class="type">size_t</span> x)</span></span>;</span><br><span class="line">Color c = red;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (c &lt; <span class="number">14.5</span>) &#123; <span class="comment">// compare Color to double (!)</span></span><br><span class="line">  <span class="keyword">auto</span> factors = <span class="built_in">primeFactors</span>(c);<span class="comment">// compute prime factors of a Color (!)</span></span><br><span class="line">…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 unscoped enums 里面的 enumerators 是被隐式转换为整数类型的，所以上面的代码不会出错。但是 scoped enums 是没有这种隐式类型转换的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span> &#123; black, white, red &#125;; <span class="comment">// enum is now scoped</span></span><br><span class="line">Color c = Color::red; <span class="comment">// as before, but</span></span><br><span class="line">…                     <span class="comment">// with scope qualifier</span></span><br><span class="line"><span class="keyword">if</span> (c &lt; <span class="number">14.5</span>) &#123; <span class="comment">// error! can&#x27;t compare</span></span><br><span class="line">                <span class="comment">// Color and double</span></span><br><span class="line">  <span class="keyword">auto</span> factors = <span class="built_in">primeFactors</span>(c); <span class="comment">// error! can&#x27;t pass Color to</span></span><br><span class="line">                                  <span class="comment">// function expecting std::size_t</span></span><br><span class="line">…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若真的想用，得用显示类型转换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(c) &lt; <span class="number">14.5</span>) &#123; <span class="comment">// odd code, but</span></span><br><span class="line">                                     <span class="comment">// it&#x27;s valid</span></span><br><span class="line">  <span class="keyword">auto</span> factors = <span class="built_in">primeFactors</span>(<span class="built_in">static_cast</span>&lt;std::<span class="type">size_t</span>&gt;(c)); <span class="comment">// suspect, but it compiles</span></span><br><span class="line">…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 C++98，是不允许 enum 提前声明(forward-declared)的，因为编译器要根据 enum 里面 enumerators 的数量来决定用什么类型来表示这个 enum，从而提高程序的<strong>空间使用效率&#x2F;运行速度</strong>。在 C++11 中允许了 forward-declared，这是因为 C++11 默认了 enumerators 的类型。想自己修改也行：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Status</span>; <span class="comment">// underlying type is int</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Status</span>: std::<span class="type">uint32_t</span>; <span class="comment">// underlying type for</span></span><br><span class="line">                                  <span class="comment">// Status is std::uint32_t</span></span><br><span class="line">                                  <span class="comment">// (from &lt;cstdint&gt;)</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Status</span>: std::<span class="type">uint32_t</span> &#123; </span><br><span class="line">	good = <span class="number">0</span>,</span><br><span class="line">  failed = <span class="number">1</span>,</span><br><span class="line">  incomplete = <span class="number">100</span>,</span><br><span class="line">  corrupt = <span class="number">200</span>,</span><br><span class="line">  audited = <span class="number">500</span>,</span><br><span class="line">  indeterminate = <span class="number">0xFFFFFFFF</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span>: std::<span class="type">uint8_t</span>;</span><br></pre></td></tr></table></figure>

<p>unscoped enums 也不是一无是处，它 space leaking 的特点也具有一定的价值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UserInfo =          <span class="comment">// type alias; see Item 9</span></span><br><span class="line">  std::tuple&lt;</span><br><span class="line">    std::string, <span class="comment">// name</span></span><br><span class="line">    std::string,            <span class="comment">// email</span></span><br><span class="line">    std::<span class="type">size_t</span>&gt; ;          <span class="comment">// reputation</span></span><br><span class="line">UserInfo uInfo; <span class="comment">// object of tuple type</span></span><br><span class="line">…</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> val = std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(uInfo); <span class="comment">// get value of field 1</span></span><br><span class="line"><span class="comment">// 显然这里使用 get&lt;1&gt; 是想要得到 email 地址，然而这并不直观并且不易维护</span></span><br><span class="line"><span class="comment">// 利用 unscoped enums 可以改变这点</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">UserInfoFields</span> &#123; uiName, uiEmail, uiReputation &#125;;</span><br><span class="line">UserInfo uInfo; <span class="comment">// as before</span></span><br><span class="line">…</span><br><span class="line"><span class="keyword">auto</span> val = std::<span class="built_in">get</span>&lt;uiEmail&gt;(uInfo); <span class="comment">// ah, get value of</span></span><br><span class="line">                                     <span class="comment">// email field</span></span><br></pre></td></tr></table></figure>

<p>注意上面的代码使用了 unscoped enums 的隐式类型转换。<br>如果在这里想用使用 scoped enums 也行：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">UserInfoFields</span> &#123; uiName, uiEmail, uiReputation &#125;;</span><br><span class="line">UserInfo uInfo; <span class="comment">// as before</span></span><br><span class="line">…</span><br><span class="line"><span class="keyword">auto</span> val =</span><br><span class="line">  std::get&lt;<span class="built_in">static_cast</span>&lt;std::<span class="type">size_t</span>&gt;(UserInfoFields::uiEmail)&gt;(uInfo);</span><br></pre></td></tr></table></figure>

<p>但这显得有点繁杂，那是不是可以用一个返回 size_t 的函数代替 static_cast 呢？这是一个 tricky 的地方：std::get&lt; &gt; 是一个模板，尖括号里面的值的类型需要在编译时就能知道，否则编译器不能将模板实例化，从而导致编译失败。因此我们需要一个 constexpr 函数模板，它可以返回任意类型的 enum：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">typename</span> std::underlying_type&lt;E&gt;::<span class="function">type</span></span><br><span class="line"><span class="function">  <span class="title">toUType</span><span class="params">(E enumerator)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> std::underlying_type&lt;E&gt;::type&gt;(enumerator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C++14 可以改成：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E&gt; <span class="comment">// C++14</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> std::<span class="type">underlying_type_t</span>&lt;E&gt;</span></span><br><span class="line"><span class="function">  <span class="title">toUType</span><span class="params">(E enumerator)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;std::<span class="type">underlying_type_t</span>&lt;E&gt;&gt;(enumerator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或用上 auto：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E&gt; <span class="comment">// C++14</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span></span></span><br><span class="line"><span class="function">  <span class="title">toUType</span><span class="params">(E enumerator)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;std::<span class="type">underlying_type_t</span>&lt;E&gt;&gt;(enumerator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，获取 email 的信息可以这样用了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> val = std::<span class="built_in">get</span>&lt;<span class="built_in">toUType</span>(UserInfoFields::uiEmail)&gt;(uInfo);</span><br></pre></td></tr></table></figure>

<p><strong>Things to remember</strong></p>
<ul>
<li>C++98-style enums are now known as unscoped enums.</li>
<li>Enumerators of scoped enums are visible only within the enum. They convert to other types only with a cast.</li>
<li>Both scoped and unscoped enums support specification of the underlying type. The default underlying type for scoped enums is int. Unscoped enums have no default underlying type.</li>
<li>Scoped enums may always be forward-declared. Unscoped enums may be forward-declared only if their declaration specifies an underlying type.</li>
</ul>
<h2 id="Item-11-使用-deleted-函数而不是-private-undefined-函数"><a href="#Item-11-使用-deleted-函数而不是-private-undefined-函数" class="headerlink" title="Item 11:使用 deleted 函数而不是 private undefined 函数"></a>Item 11:使用 deleted 函数而不是 private undefined 函数</h2><p>如果你想避免其他开发者使用某些函数，一般来说不定义这个函数就行了（这不显然么）。然而其实并没那么显然，在定义一个类时，C++ 会自己定义一些函数（在 item 17(这里到时加个链接) 中有详细介绍）。比如流的拷贝问题。在C++ 标准库中有个 basic_ios 的模板类，所有的输出、输入流都继承自这个模板类。对流的拷贝的作用并不清楚，所以要避免用户对流进行拷贝。最简单的做法是做一个空的定义，下面的代码来自 C++98（包括注释）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">charT</span>, <span class="keyword">class</span> <span class="title class_">traits</span> = char_traits&lt;charT&gt; &gt;</span><br><span class="line"><span class="keyword">class</span> basic_ios : <span class="keyword">public</span> ios_base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">…</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">basic_ios</span>(<span class="type">const</span> basic_ios&amp; );           <span class="comment">// not defined</span></span><br><span class="line">  basic_ios&amp; <span class="keyword">operator</span>=(<span class="type">const</span> basic_ios&amp;); <span class="comment">// not defined</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但是这样的话成员函数或是友元都有权限使用 private 里面的函数。C++11 有更好的做法—— deleted functions:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">charT</span>, <span class="keyword">class</span> <span class="title class_">traits</span> = char_traits&lt;charT&gt; &gt;</span><br><span class="line"><span class="keyword">class</span> basic_ios : <span class="keyword">public</span> ios_base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">…</span><br><span class="line">  <span class="built_in">basic_ios</span>(<span class="type">const</span> basic_ios&amp; ) = <span class="keyword">delete</span>;</span><br><span class="line">  basic_ios&amp; <span class="keyword">operator</span>=(<span class="type">const</span> basic_ios&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">…</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用 delete 会让你在编译前就知道对这些函数的调用是不合法的，而若是友元等访问未定义的 private 函数，会在编译时才能知道。<br>有个小细节，deleted functions 是定义在 public 里的，原因是 C++ 会先检查函数的可访问性（accessibility），然后才检查函数的删除属性（deleted status）。如果放在 private 里面，C++ 可能只会说函数在 private 不能访问，而不是说该函数不能使用。因此，将代码的 private-and-not-defined 成员改成 public deleted 成员有益于改进 error 信息。  </p>
<p>另外，deleted functions 可以用在其他的非成员函数上，如我们定义一个函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isLucky</span><span class="params">(<span class="type">int</span> number)</span></span>;</span><br></pre></td></tr></table></figure>

<p>有这么一些对它的调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">isLucky</span>(<span class="string">&#x27;a&#x27;</span>)) … <span class="comment">// is &#x27;a&#x27; a lucky number?</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isLucky</span>(<span class="literal">true</span>)) … <span class="comment">// is &quot;true&quot;?</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isLucky</span>(<span class="number">3.5</span>)) … <span class="comment">// should we truncate to 3</span></span><br><span class="line">                    <span class="comment">// before checking for luckiness?</span></span><br></pre></td></tr></table></figure>

<p>如果我们想保证函数的输入只有整数的，可以使用 deleted function 来避免使用类型转换的合法类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isLucky</span><span class="params">(<span class="type">int</span> number)</span></span>; <span class="comment">// original function</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isLucky</span><span class="params">(<span class="type">char</span>)</span> </span>= <span class="keyword">delete</span>; <span class="comment">// reject chars</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isLucky</span><span class="params">(<span class="type">bool</span>)</span> </span>= <span class="keyword">delete</span>; <span class="comment">// reject bools</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isLucky</span><span class="params">(<span class="type">double</span>)</span> </span>= <span class="keyword">delete</span>; <span class="comment">// reject doubles and floats</span></span><br></pre></td></tr></table></figure>

<p>deleted functions 还能避免模板函数的不合适的实例化。比如我们有一个作用于内置指针的模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processPointer</span><span class="params">(T* ptr)</span></span>;</span><br></pre></td></tr></table></figure>

<p>在 C++ 中，有两类特殊的指针。一类是 void* 指针，因为它们不能被解引用或自增、自减；另一类是 char* 指针，因为它们指向的是 C 风格的字符串，而不是单个的 char。想避免使用这些指针类型的调用，可以用 deleted functions：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">processPointer</span>&lt;<span class="type">void</span>&gt;(<span class="type">void</span>*) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">processPointer</span>&lt;<span class="type">char</span>&gt;(<span class="type">char</span>*) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure>

<p>另外，使用 const void* 和 const char* 的调用也应该被避免：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">processPointer</span>&lt;<span class="type">const</span> <span class="type">void</span>&gt;(<span class="type">const</span> <span class="type">void</span>*) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">processPointer</span>&lt;<span class="type">const</span> <span class="type">char</span>&gt;(<span class="type">const</span> <span class="type">char</span>*) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure>

<p>如果还想彻底点，还有 const volatile void* 和 const volatile char* ，然而暂时不懂 volatile（划掉）。  </p>
<p>如果是在类里使用模板，像下面的代码是不会编译的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">…</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">  <span class="type">void</span> <span class="title">processPointer</span><span class="params">(T* ptr)</span></span></span><br><span class="line"><span class="function">  </span>&#123; … &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">template</span>&lt;&gt; <span class="comment">// error!</span></span><br><span class="line">  <span class="type">void</span> <span class="built_in">processPointer</span>&lt;<span class="type">void</span>&gt;(<span class="type">void</span>*);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其原因是对模板的特殊规定只能在命名空间（namespace scope）里写，而不能在类空间(class scope)。下面的代码可以实现上面代码的效果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  …</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">  <span class="type">void</span> <span class="title">processPointer</span><span class="params">(T* ptr)</span></span></span><br><span class="line"><span class="function">  </span>&#123; … &#125;</span><br><span class="line">  …</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; </span><br><span class="line"><span class="type">void</span> Widget::<span class="built_in">processPointer</span>&lt;<span class="type">void</span>&gt;(<span class="type">void</span>*) = <span class="keyword">delete</span>; <span class="comment">// still public but deleted</span></span><br></pre></td></tr></table></figure>

<p>总结一下，C++98 的 private-and-not-defined 成员实现的就是 C++11 中 deleted functions 实现的效果，但它在类外不能用，在类内不一定能用，就算能用了也要等到链接（link-time）时才能起作用。所以坚持使用 deleted functions 吧。  </p>
<p><strong>Things to Remember</strong></p>
<ul>
<li>Prefer deleted functions to private undefined ones.</li>
<li>Any function may be deleted, including non-member functions and template instantiations.</li>
</ul>
<h2 id="Item-12-将重写的函数声明为-override"><a href="#Item-12-将重写的函数声明为-override" class="headerlink" title="Item 12:将重写的函数声明为 override"></a>Item 12:将重写的函数声明为 override</h2><p>虚函数是 C++ 的类的一个工具。你可以在基类（base class）中定义或声明虚函数，并在派生类（derived classed）中重写（override）这个虚函数。然而何时该调用 overrided 的虚函数并不显然。先看下面这个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">doWork</span><span class="params">()</span></span>; <span class="comment">// base class virtual function</span></span><br><span class="line">…</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">doWork</span><span class="params">()</span></span>; <span class="comment">// overrides Base::doWork ,&quot;virtual&quot; is optional here</span></span><br><span class="line">  … </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// create base class pointer to derived class object;</span></span><br><span class="line"><span class="comment">// see Item 21 for info on std::make_unique</span></span><br><span class="line">std::unique_ptr&lt;Base&gt; upb = std::<span class="built_in">make_unique</span>&lt;Derived&gt;(); </span><br><span class="line">… </span><br><span class="line">upb-&gt;<span class="built_in">doWork</span>(); <span class="comment">// call doWork through base class ptr; derived class function is invoked</span></span><br></pre></td></tr></table></figure>

<p>上面这个例子，就是通过了一个基类的接口，调用了派生类的函数。<br>重写（Overring）的发生有以下几个必要要求：</p>
<ul>
<li>基类函数必须是<strong>虚函数（virtual）</strong></li>
<li>基类与派生类的该函数（下称基派函）<strong>同名</strong>（除了析构函数）</li>
<li>基派函<strong>参数一致</strong></li>
<li>基派函<strong>const 性（constness）一致</strong></li>
<li>基派函<strong>返回类型与 exception specifications 兼容（compatible)</strong></li>
</ul>
<p>C++11 还加了一点：  </p>
<ul>
<li>基派函<strong>引用限定符（reference qualifiers）一致</strong></li>
</ul>
<p>成员函数的引用限定符可以用来保证函数只被用于左值或右值，如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">…</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">()</span> &amp;</span>; <span class="comment">// this version of doWork applies only when *this is an lvalue</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">()</span> &amp;&amp;</span>; <span class="comment">// this version of doWork applies only when *this is an rvalue</span></span><br><span class="line">&#125;;                 </span><br><span class="line">…</span><br><span class="line"><span class="function">Widget <span class="title">makeWidget</span><span class="params">()</span></span>; <span class="comment">// factory function (returns rvalue)</span></span><br><span class="line">Widget w; <span class="comment">// normal object (an lvalue)</span></span><br><span class="line">…</span><br><span class="line">w.<span class="built_in">doWork</span>(); <span class="comment">// calls Widget::doWork for lvalues (i.e., Widget::doWork &amp;)</span></span><br><span class="line"><span class="built_in">makeWidget</span>().<span class="built_in">doWork</span>(); <span class="comment">// calls Widget::doWork for rvalues (i.e., Widget::doWork &amp;&amp;)</span></span><br></pre></td></tr></table></figure>

<p>由重写引起的错误并不会被编译器发现，因为它是往往合法的，只是没有按你的原目的进行。如下面的代码，就完全没有任何重写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf2</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf3</span><span class="params">()</span> &amp;</span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">mf4</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span></span>;               <span class="comment">// 没 const</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf2</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> x)</span></span>; <span class="comment">// 多了 unsigned</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf3</span><span class="params">()</span> &amp;&amp;</span>;            <span class="comment">// &amp; &amp;&amp;</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">mf4</span><span class="params">()</span> <span class="type">const</span></span>;                 <span class="comment">// base 不是 virtual</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>C++11 给出了避免上面这种情况的方案：把要重写的函数声明为 override：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf2</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> x)</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf3</span><span class="params">()</span> &amp;&amp; <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf4</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样，上面的代码就会因为重写失败而产生错误。</p>
<p>在 C++98 中也有 override：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Warning</span> &#123; <span class="comment">// potential legacy class from C++98</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">…</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">override</span><span class="params">()</span></span>; <span class="comment">// legal in both C++98 and C++11</span></span><br><span class="line">…                <span class="comment">// (with the same meaning)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>所以如果看见老代码用了 override 函数并不用改。<br>接下来补充一下引用限定符（reference qualifiers）的内容。假设有个Widget：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">using</span> DataType = std::vector&lt;<span class="type">double</span>&gt;; <span class="comment">// see Item 9 for</span></span><br><span class="line">	…                                     <span class="comment">// info on &quot;using&quot;</span></span><br><span class="line">	<span class="function">DataType&amp; <span class="title">data</span><span class="params">()</span> &amp; </span>&#123; <span class="keyword">return</span> values; &#125;</span><br><span class="line">	<span class="function">DataType <span class="title">data</span><span class="params">()</span> &amp;&amp; </span>&#123; <span class="keyword">return</span> std::<span class="built_in">move</span>(values); &#125;<span class="comment">// for rvalue Widgets, return rvalue</span></span><br><span class="line">	…</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">	DataType values;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给出两种调用</span></span><br><span class="line">Widget w;</span><br><span class="line">…</span><br><span class="line"><span class="keyword">auto</span> vals1 = w.<span class="built_in">data</span>(); <span class="comment">// copy w.values into vals1</span></span><br><span class="line"></span><br><span class="line"><span class="function">Widget <span class="title">makeWidget</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">auto</span> vals2 = <span class="built_in">makeWidget</span>().<span class="built_in">data</span>();</span><br></pre></td></tr></table></figure>

<p>这样，vals1 和 vals2 调用的是不同的 data() 函数。这就是 接受右值的函数定义 的作用。</p>
<p><strong>Things to Remember</strong></p>
<ul>
<li>Declare overriding functions override.</li>
<li>Member function reference qualifiers make it possible to treat lvalue and rvalue objects (*<strong>this</strong>) differently.</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/11/EMC-notes-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wizlyk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wizlyk">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/08/11/EMC-notes-2/" class="post-title-link" itemprop="url">auto - Effective Modern C++阅读笔记（二）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-08-11 09:45:23" itemprop="dateCreated datePublished" datetime="2019-08-11T09:45:23+08:00">2019-08-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-29 20:38:11" itemprop="dateModified" datetime="2022-11-29T20:38:11+08:00">2022-11-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>本文所有内容参考于 《Effective Modern C++》（Scott Meyers）一书，仅供个人学习</code></p>
<h1 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h1><h2 id="Item-5-多用auto替换显式类型声明"><a href="#Item-5-多用auto替换显式类型声明" class="headerlink" title="Item 5:多用auto替换显式类型声明"></a>Item 5:多用auto替换显式类型声明</h2><p>auto有很多好处：</p>
<h3 id="可以避免未定义的情况："><a href="#可以避免未定义的情况：" class="headerlink" title="可以避免未定义的情况："></a>可以避免未定义的情况：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x1; <span class="comment">// potentially uninitialized</span></span><br><span class="line"><span class="keyword">auto</span> x2; <span class="comment">// error! initializer required</span></span><br><span class="line"><span class="keyword">auto</span> x3 = <span class="number">0</span>; <span class="comment">// fine, x&#x27;s value is well-defined</span></span><br></pre></td></tr></table></figure>

<h3 id="可以避免繁琐的类型声明，且可以随参数改变："><a href="#可以避免繁琐的类型声明，且可以随参数改变：" class="headerlink" title="可以避免繁琐的类型声明，且可以随参数改变："></a>可以避免繁琐的类型声明，且可以随参数改变：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> It&gt; <span class="comment">// 设It是一个迭代器类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dwim</span><span class="params">(It b, It e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (b != e) &#123;</span><br><span class="line">    <span class="keyword">auto</span> currValue = *b;</span><br><span class="line">    …</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在C++14中，还可以在lambda表达式中使用<strong>auto</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> derefUPLess =                      <span class="comment">// comparison func.</span></span><br><span class="line">  [](<span class="type">const</span> std::unique_ptr&lt;Widget&gt;&amp; p1, <span class="comment">// for Widgets</span></span><br><span class="line">  <span class="type">const</span> std::unique_ptr&lt;Widget&gt;&amp; p2)    <span class="comment">// pointed to by</span></span><br><span class="line">&#123; <span class="keyword">return</span> *p1 &lt; *p2; &#125;;                  <span class="comment">// std::unique_ptrs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> derefLess =       <span class="comment">// C++14 comparison</span></span><br><span class="line">  [](<span class="type">const</span> <span class="keyword">auto</span>&amp; p1,   <span class="comment">// function for</span></span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span>&amp; p2)      <span class="comment">// values pointed</span></span><br><span class="line">&#123; <span class="keyword">return</span> *p1 &lt; *p2; &#125;; <span class="comment">// to by anything pointer-like</span></span><br></pre></td></tr></table></figure>

<p>书中提到了std::function 对象：在C++11标准库中，std::function 是一个产生类似于函数指针的模板。与函数指针不同的是，函数指针只能指向函数，而std::function 可以指向所有的可调用对象。如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::function&lt;<span class="type">bool</span>(<span class="type">const</span> std::unique_ptr&lt;Widget&gt;&amp;,</span><br><span class="line">                   <span class="type">const</span> std::unique_ptr&lt;Widget&gt;&amp;)&gt; func;</span><br><span class="line"></span><br><span class="line">std::function&lt;<span class="type">bool</span>(<span class="type">const</span> std::unique_ptr&lt;Widget&gt;&amp;,</span><br><span class="line">                   <span class="type">const</span> std::unique_ptr&lt;Widget&gt;&amp;)&gt;</span><br><span class="line">derefUPLess = [](<span class="type">const</span> std::unique_ptr&lt;Widget&gt;&amp; p1,</span><br><span class="line">                 <span class="type">const</span> std::unique_ptr&lt;Widget&gt;&amp; p2)</span><br><span class="line">&#123; <span class="keyword">return</span> *p1 &lt; *p2; &#125;;</span><br></pre></td></tr></table></figure>

<p>由于 std::function 是一个模板，所以它会比 auto 使用更多的空间。  </p>
<h3 id="auto-可以避免不合适的类型声明"><a href="#auto-可以避免不合适的类型声明" class="headerlink" title="auto 可以避免不合适的类型声明"></a>auto 可以避免不合适的类型声明</h3><p>比如下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">…</span><br><span class="line"><span class="type">unsigned</span> sz = v.<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure>

<p>一般情况下这没有问题，然而 <strong>unsigned</strong> 和 <strong>std::vector&lt;int&gt;::size_type</strong> 并不完全一致。  </p>
<p>在32位的Windows系统中，两者一致；在64位的 Windows 系统中，<strong>unsigned</strong> 是32位的，而 <strong>std::vector&lt;int&gt;::size_type</strong> 是64位的,从而可能导致错误。  </p>
<p>再看下面的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::unordered_map&lt;std::string, <span class="type">int</span>&gt; m;</span><br><span class="line">…</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> std::pair&lt;std::string, <span class="type">int</span>&gt;&amp; p : m)</span><br><span class="line">&#123;</span><br><span class="line">… <span class="comment">// do something with p</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是不是一眼看上去并没有错误？然而在 std::unordered_map 中的 key 是 <strong>const</strong> 类型的，也就是说 pair 应该为 **std::pair&lt;const std::string, int&gt;**。使用 auto 就能避免这种错误的类型声明。  </p>
<p><strong>Things to Remember</strong></p>
<ul>
<li>auto variables must be initialized, are generally immune to type mismatches that can lead to portability or efficiency problems, can ease the process of refactoring, and typically require less typing than variables with explicitly specified types.</li>
<li>auto-typed variables are subject to the pitfalls described in Items 2 and 6.</li>
</ul>
<h2 id="Item-6-用显示类型声明来避免-auto-的不合适推断"><a href="#Item-6-用显示类型声明来避免-auto-的不合适推断" class="headerlink" title="Item 6:用显示类型声明来避免 auto 的不合适推断"></a>Item 6:用显示类型声明来避免 auto 的不合适推断</h2><p>有意思的是，瞎用auto也会导致错误，<strong>std::vector&lt;bool&gt;</strong> 就是一个典型的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">bool</span>&gt; <span class="title">features</span><span class="params">(<span class="type">const</span> Widget&amp; w)</span></span>;</span><br><span class="line">Widget w;</span><br><span class="line">…</span><br><span class="line"><span class="type">bool</span> highPriority = <span class="built_in">features</span>(w)[<span class="number">5</span>]; <span class="comment">// is w high priority?</span></span><br><span class="line"><span class="built_in">processWidget</span>(w, highPriority); <span class="comment">// process w in accord with its priority</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> highPriority_auto = <span class="built_in">features</span>(w)[<span class="number">5</span>];</span><br><span class="line"><span class="built_in">processWidget</span>(w, highPriority_auto); <span class="comment">// undefined behavior!</span></span><br></pre></td></tr></table></figure>

<p>一般来说，std::vector::operator[] 会返回相应的引用类型，唯独除了 bool 。这是由于C++在实现 vector&lt;bool&gt; 时是根据二进制数某位上的值来得到各个value的，而C++禁止对位的引用，所以 operator[] 会返回 std::vector&lt;bool&gt;::reference 作为替代，它使用起来就和 bool&amp; 类似。然而，在上面的代码中，我们想要的是<strong>bool</strong>类型而不是 reference ，所以这里应该使用显式的 bool 类型声明。</p>
<p>更进一步的，仔细看上面这段代码，feature(w) 产生了一个临时变量，而 feature(w)[5] 是对这个临时变量的 vector&lt;bool&gt;::reference 。因此，highPriority_auto 实际包含了对这个临时变量的元素的指针，这导致在下一句中， highPriority_auto 包含了一个空指针，从而导致严重错误。</p>
<p><strong>Proxy Class</strong><br>Proxy class: a class that exists for the purpose of emulating and augmenting the behavior of some other type.<br>Proxy 类的目的模仿或改进某个类型的行为。如 std::vector&lt;bool&gt;::reference 就是一个<strong>proxy class</strong>，用来模仿 vector&lt;bool&gt;的operator[]，让其看起来像是返回了一个bool&amp;。<br>智能指针 std::shared_ptr 和 std::unique_ptr 等也是 Proxy class，为了改进 生指针(Raw pointer) 在资源管理上的行为。<br>说白了，proxy class 的作用就是产生一个代理(proxy)，若对含有 proxy class 的代码使用 auto ，很可能会得到 proxy class的类型而不是<strong>看上去</strong>直接的类型。</p>
<p>如果非要用 auto 也不是不行：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> highPriority = <span class="built_in">static_cast</span>&lt;<span class="type">bool</span>&gt;(<span class="built_in">features</span>(w)[<span class="number">5</span>]);</span><br></pre></td></tr></table></figure>

<p><strong>Things to Remember</strong></p>
<ul>
<li>“Invisible” proxy types can cause auto to deduce the “wrong” type for an initializing expression.</li>
<li>The explicitly typed initializer idiom forces auto to deduce the type you want it to have.</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/11/EMC-notes-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wizlyk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wizlyk">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/08/11/EMC-notes-1/" class="post-title-link" itemprop="url">Deducing Types - 《Effective Modern C++》阅读笔记（一）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-08-11 09:31:07" itemprop="dateCreated datePublished" datetime="2019-08-11T09:31:07+08:00">2019-08-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-29 20:38:11" itemprop="dateModified" datetime="2022-11-29T20:38:11+08:00">2022-11-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>本文所有内容参考于 《Effective Modern C++》（Scott Meyers）一书，仅供个人学习 </code></p>
<h1 id="Deducing-Types-类型推断"><a href="#Deducing-Types-类型推断" class="headerlink" title="Deducing Types (类型推断)"></a>Deducing Types (类型推断)</h1><h2 id="Item-1-理解模板类型推断"><a href="#Item-1-理解模板类型推断" class="headerlink" title="Item 1:理解模板类型推断"></a>Item 1:理解模板类型推断</h2><p><strong>模板函数声明中的类型</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(ParamType param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">27</span>; <span class="comment">// x is an int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> cx = x; <span class="comment">// cx is a const int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; rx = x; <span class="comment">// rx is a reference to x as a const int</span></span><br></pre></td></tr></table></figure>

<p>ParamType为普通引用,即 ParamType 为 T&amp;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp; param)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp; param)</span></span>;</span><br><span class="line"><span class="built_in">f</span>(x); <span class="comment">// T is int, param&#x27;s type is int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(cx); <span class="comment">// T is const int,</span></span><br><span class="line">       <span class="comment">// param&#x27;s type is const int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(rx); <span class="comment">// T is const int,</span></span><br><span class="line">       <span class="comment">// param&#x27;s type is const int&amp;</span></span><br></pre></td></tr></table></figure>

<p>ParamType 为 const T&amp;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> T&amp; param)</span></span>;</span><br><span class="line"><span class="built_in">f</span>(x);  <span class="comment">// T is int, param&#x27;s type is const int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(cx); <span class="comment">// T is int, param&#x27;s type is const int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(rx); <span class="comment">// T is int, param&#x27;s type is const int&amp;</span></span><br></pre></td></tr></table></figure>

<p>ParamType 为右值引用 T&amp;&amp;，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;</span><br><span class="line"><span class="built_in">f</span>(x); <span class="comment">// x is lvalue, so T is int&amp;,</span></span><br><span class="line">      <span class="comment">// param&#x27;s type is also int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(cx); <span class="comment">// cx is lvalue, so T is const int&amp;,</span></span><br><span class="line">       <span class="comment">// param&#x27;s type is also const int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(rx); <span class="comment">// rx is lvalue, so T is const int&amp;,</span></span><br><span class="line">       <span class="comment">// param&#x27;s type is also const int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">27</span>); <span class="comment">// 27 is rvalue, so T is int,</span></span><br><span class="line">       <span class="comment">// param&#x27;s type is therefore int&amp;&amp;</span></span><br></pre></td></tr></table></figure>

<p>在《C++ Primer》16.2.5中介绍了这种情况：“当我们将一个左值传递给函数的优质引用参数，且此右值引用指向模板类型参数（如T&amp;&amp;）时，编译器推断模板类型参数为实参的左值引用类型。”因此f(x)中T为int&amp;， f(cx)中T为const int&amp;。同时，“我们不能（直接）定义一个引用的引用”，这时有另外的一个规则，叫<strong>引用折叠</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">引用折叠:</span><br><span class="line">- X&amp; &amp;、X&amp; &amp;&amp;和X&amp;&amp; &amp;都折叠成类型X&amp;</span><br><span class="line">- 类型X&amp;&amp; &amp;&amp;折叠成X&amp;&amp;</span><br><span class="line">- 当传入的是左值时，类型推断会推向左值引用；若传入的是右值才推为右值引用。</span><br></pre></td></tr></table></figure>

<p>ParamType 是值，T</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T param)</span></span>;</span><br><span class="line"><span class="built_in">f</span>(x);  <span class="comment">// T&#x27;s and param&#x27;s types are both int</span></span><br><span class="line"><span class="built_in">f</span>(cx); <span class="comment">// T&#x27;s and param&#x27;s types are again both int</span></span><br><span class="line"><span class="built_in">f</span>(rx); <span class="comment">// T&#x27;s and param&#x27;s types are still both int</span></span><br></pre></td></tr></table></figure>

<p>会将传入的值去引用，并去const。</p>
<p><strong>当传入数组会怎么样？</strong> 是的，聪明的你会发现下面的格式是错的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunc</span><span class="params">(<span class="type">int</span> param[])</span></span>;</span><br></pre></td></tr></table></figure>

<p>在数组名字单独出现时，往往被视作一个指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunc</span><span class="params">(<span class="type">int</span>* param)</span></span>;</span><br></pre></td></tr></table></figure>

<p>然而我们可以声明一个参数是对一个数组的引用。设name是一个长度为13的const char[]。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp; param)</span></span>; <span class="comment">// template with by-reference parameter</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(name); <span class="comment">// pass array to f</span></span><br></pre></td></tr></table></figure>

<p>T会被推断为const char [13]，f的参数是const char (&amp;)[13]。<br>进一步的，如果想知道一个数组的大小，可以像下面这样</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> N&gt; </span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> std::<span class="type">size_t</span> <span class="title">arraySize</span><span class="params">(T (&amp;)[N])</span> <span class="keyword">noexcept</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> N; </span><br><span class="line">&#125; <span class="comment">// 注意以后会提到的constexpr &amp; noexcept</span></span><br></pre></td></tr></table></figure>

<p>最后给出书中的tips。</p>
<p><strong>Things to Remember</strong></p>
<ul>
<li>During template type deduction, arguments that are references are treated as non-references, i.e., their reference-ness is ignored.</li>
<li>When deducing types for universal reference parameters, lvalue arguments get special treatment.</li>
<li>When deducing types for by-value parameters, const and&#x2F;or volatile arguments are treated as non-const and non-volatile.</li>
<li>During template type deduction, arguments that are array or function names decay to pointers, unless they’re used to initialize references.</li>
</ul>
<p><strong>存在的疑问：</strong><br>1，什么是Universal reference?<br>2，什么样的参数为volatile？</p>
<h2 id="Item-2-auto语句中的类型推断"><a href="#Item-2-auto语句中的类型推断" class="headerlink" title="Item 2:auto语句中的类型推断"></a>Item 2:auto语句中的类型推断</h2><p>如何推断下面的代码中 auto 分别代表了什么类型呢？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">27</span>;</span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> cx = x;</span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span>&amp; rx = x;</span><br></pre></td></tr></table></figure>

<p>一般情况下，可以用模板函数中的类型推断来判断auto的结果。如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; 			<span class="comment">// conceptual template for</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_for_x</span><span class="params">(T param)</span></span>; <span class="comment">// deducing x&#x27;s type</span></span><br><span class="line"><span class="built_in">func_for_x</span>(<span class="number">27</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; 						 <span class="comment">// conceptual template for</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_for_cx</span><span class="params">(<span class="type">const</span> T param)</span></span>; <span class="comment">// deducing cx&#x27;s type</span></span><br><span class="line"><span class="built_in">func_for_cx</span>(x);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; 							<span class="comment">// conceptual template for</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_for_rx</span><span class="params">(<span class="type">const</span> T&amp; param)</span></span>; <span class="comment">// deducing rx&#x27;s type</span></span><br><span class="line"><span class="built_in">func_for_rx</span>(x);</span><br></pre></td></tr></table></figure>

<p>根据 Item 1，我们可以将模板的类型推断分为三种：  </p>
<ul>
<li>Case 1: The type specifier is a pointer or reference, but not a universal reference.  </li>
<li>Case 2: The type specifier is a universal reference.  </li>
<li>Case 3: The type specifier is neither a pointer nor a reference.</li>
</ul>
<p>这样，我们可以很自然地推断出下面的例子 auto 具体指代的内容：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">27</span>; <span class="comment">// case 3 (x is neither ptr nor reference)</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> cx = x; <span class="comment">// case 3 (cx isn&#x27;t either)</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span>&amp; rx = x; <span class="comment">// case 1 (rx is a non-universal ref.)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; uref1 = x; <span class="comment">// x is int and lvalue,</span></span><br><span class="line">                  <span class="comment">// so uref1&#x27;s type is int&amp;</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; uref2 = cx; <span class="comment">// cx is const int and lvalue,</span></span><br><span class="line">                   <span class="comment">// so uref2&#x27;s type is const int&amp;</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; uref3 = <span class="number">27</span>; <span class="comment">// 27 is int and rvalue,</span></span><br><span class="line">                   <span class="comment">// so uref3&#x27;s type is int&amp;&amp;</span></span><br></pre></td></tr></table></figure>

<p>同样的，对于数组、函数，也有引用和非引用的区别</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> name[] = <span class="string">&quot;R. N. Briggs&quot;</span>;  <span class="comment">// name&#x27;s type is const char[13]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> arr1 = name;   <span class="comment">// arr1&#x27;s type is const char*</span></span><br><span class="line"><span class="keyword">auto</span>&amp; arr2 = name;  <span class="comment">// arr2&#x27;s type is const char (&amp;)[13]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunc</span><span class="params">(<span class="type">int</span>, <span class="type">double</span>)</span></span>; <span class="comment">// someFunc is a function;</span></span><br><span class="line">                            <span class="comment">// type is void(int, double)</span></span><br><span class="line"><span class="keyword">auto</span> func1 = someFunc; <span class="comment">// func1&#x27;s type is void (*)(int, double)</span></span><br><span class="line"><span class="keyword">auto</span>&amp; func2 = someFunc; <span class="comment">// func2&#x27;s type is void (&amp;)(int, double)</span></span><br></pre></td></tr></table></figure>

<p>如果用 auto 的对象是初始化列表，推断的结果也是初始化列表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = &#123;<span class="number">27</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> y = &#123;<span class="number">27</span>&#125;; <span class="comment">// type is std::initializer_list&lt;int&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这也是 auto 和模板类型推断会不同的唯一地方：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = &#123; <span class="number">11</span>, <span class="number">23</span>, <span class="number">9</span> &#125;; <span class="comment">// x&#x27;s type is</span></span><br><span class="line">                        <span class="comment">// std::initializer_list&lt;int&gt;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">// template with parameter</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T param)</span></span>;  <span class="comment">// declaration equivalent to</span></span><br><span class="line">                  <span class="comment">// x&#x27;s declaration</span></span><br><span class="line"><span class="built_in">f</span>(&#123; <span class="number">11</span>, <span class="number">23</span>, <span class="number">9</span> &#125;); <span class="comment">// error! can&#x27;t deduce type for T</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>只能像下面这样用模板推断 initializer_list:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(std::initializer_list&lt;T&gt; initList)</span></span>;</span><br><span class="line"><span class="built_in">f</span>(&#123; <span class="number">11</span>, <span class="number">23</span>, <span class="number">9</span> &#125;); <span class="comment">// T deduced as int, and initList&#x27;s</span></span><br><span class="line">                  <span class="comment">// type is std::initializer_list&lt;int&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>另外，虽然C++14允许使用 ‘auto’ 来推断函数返回类型或 lambda 函数参数，但这种用法是使用的模板类型推断。因此，若返回的是初始化列表并不能编译：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">createInitList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;; <span class="comment">// error: can&#x27;t deduce type</span></span><br><span class="line">&#125;                   <span class="comment">// for &#123; 1, 2, 3 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> resetV = [&amp;v](<span class="type">const</span> <span class="keyword">auto</span>&amp; newValue) &#123; v = newValue; &#125;; <span class="comment">// C++14</span></span><br><span class="line"><span class="built_in">resetV</span>(&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;); <span class="comment">// error! can&#x27;t deduce type for &#123; 1, 2, 3 &#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>Things to Remember</strong></p>
<ul>
<li>auto type deduction is usually the same as template type deduction, but auto type deduction assumes that a braced initializer represents a std::initial izer_list, and template type deduction doesn’t.</li>
<li>auto in a function return type or a lambda parameter implies template type deduction, not auto type deduction.</li>
</ul>
<h2 id="Item-3-理解decltype"><a href="#Item-3-理解decltype" class="headerlink" title="Item 3:理解decltype"></a>Item 3:理解decltype</h2><p>先来一些 no surprise 的例子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">0</span>;         <span class="comment">// decltype(i) is const int</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">f</span><span class="params">(<span class="type">const</span> Widget&amp; w)</span></span>; <span class="comment">// decltype(w) is const Widget&amp;</span></span><br><span class="line">                         <span class="comment">// decltype(f) is bool(const Widget&amp;)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="type">int</span> x, y;              <span class="comment">// decltype(Point::x) is int</span></span><br><span class="line">&#125;;                       <span class="comment">// decltype(Point::y) is int</span></span><br><span class="line">Widget w;                <span class="comment">// decltype(w) is Widget</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">f</span>(w)) …              <span class="comment">// decltype(f(w)) is bool</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;     <span class="comment">// simplified version of std::vector</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">vector</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  …</span><br><span class="line">  T&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> index);</span><br><span class="line">  …</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;           <span class="comment">// decltype(v) is vector&lt;int&gt;</span></span><br><span class="line">…</span><br><span class="line"><span class="keyword">if</span> (v[<span class="number">0</span>] == <span class="number">0</span>) …         <span class="comment">// decltype(v[0]) is int&amp;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在C++11中，decltype 主要用于函数返回类型(return type)基于参数类型(parameter types)的情况：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Index&gt; <span class="comment">// works, but</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">authAndAccess</span><span class="params">(Container&amp; c, Index i)</span>    <span class="comment">// requires</span></span></span><br><span class="line"><span class="function">-&gt; <span class="title">decltype</span><span class="params">(c[i])</span>                            <span class="comment">// refinement</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">authenticateUser</span>();</span><br><span class="line">  <span class="keyword">return</span> c[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在C++14中可以直接使用 auto 作为返回类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Index&gt; <span class="comment">// C++14;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">authAndAccess</span><span class="params">(Container&amp; c, Index i)</span>    <span class="comment">// not quite</span></span></span><br><span class="line"><span class="function"></span>&#123;                                            <span class="comment">// correct</span></span><br><span class="line">  <span class="built_in">authenticateUser</span>();</span><br><span class="line">  <span class="keyword">return</span> c[i]; <span class="comment">// return type deduced from c[i]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>值得注意的是，尽管 c[i] 一般返回的是引用类型，但由于模板类型推断是去引用的，所以下面的代码是错误的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">…</span><br><span class="line"><span class="built_in">authAndAccess</span>(d, <span class="number">5</span>) = <span class="number">10</span>; <span class="comment">// authenticate user, return d[5],</span></span><br><span class="line">                          <span class="comment">// then assign 10 to it;</span></span><br><span class="line">                          <span class="comment">// this won&#x27;t compile!</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里，函数 authAndAccess 返回的是一个右值(rvalue)，C++ 中给右值赋值是被禁止的。  </p>
<p>C++14可以 decltype(auto) 来实现返回与c[i]一致的类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Index&gt; <span class="comment">// C++14; works,</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>)                               <span class="comment">// but still</span></span><br><span class="line"><span class="built_in">authAndAccess</span>(Container&amp; c, Index i)         <span class="comment">// requires</span></span><br><span class="line">&#123;                                            <span class="comment">// refinement</span></span><br><span class="line"><span class="built_in">authenticateUser</span>();</span><br><span class="line"><span class="keyword">return</span> c[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>decltype(auto)也可以用在变量的声明中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Widget w;</span><br><span class="line"><span class="type">const</span> Widget&amp; cw = w;</span><br><span class="line"><span class="keyword">auto</span> myWidget1 = cw; <span class="comment">// auto type deduction:</span></span><br><span class="line">                     <span class="comment">// myWidget1&#x27;s type is Widget</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) myWidget2 = cw; <span class="comment">// decltype type deduction:</span></span><br><span class="line">                               <span class="comment">// myWidget2&#x27;s type is</span></span><br><span class="line">                               <span class="comment">// const Widget&amp;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>decltype 的 surprise 出现在右值容器上。用户可能只想得到临时容器中的拷贝，如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::deque&lt;std::string&gt; <span class="title">makeStringDeque</span><span class="params">()</span></span>; <span class="comment">// factory function</span></span><br><span class="line"><span class="comment">// make copy of 5th element of deque returned</span></span><br><span class="line"><span class="comment">// from makeStringDeque</span></span><br><span class="line"><span class="keyword">auto</span> s = <span class="built_in">authAndAccess</span>(<span class="built_in">makeStringDeque</span>(), <span class="number">5</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这时用decltype(auto)就会得到对容器元素的引用，这是并不安全的。为了让 authAndAccess 能同时接受左值和右值，需要用上Universal reference：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Index&gt; <span class="comment">// c is now a</span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">authAndAccess</span><span class="params">(Container&amp;&amp; c, <span class="comment">// universal</span></span></span></span><br><span class="line"><span class="params"><span class="function">                             Index i)</span></span>; <span class="comment">// reference</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>书上还提到了forward，虽然不太了解还是放上来吧：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Index&gt; <span class="comment">// final</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>)                               <span class="comment">// C++14</span></span><br><span class="line"><span class="built_in">authAndAccess</span>(Container&amp;&amp; c, Index i)        <span class="comment">// version</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">authenticateUser</span>();</span><br><span class="line"><span class="keyword">return</span> std::forward&lt;Container&gt;(c)[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Index&gt; <span class="comment">// final</span></span><br><span class="line"><span class="keyword">auto</span>                                         <span class="comment">// C++11</span></span><br><span class="line"><span class="built_in">authAndAccess</span>(Container&amp;&amp; c, Index i)        <span class="comment">// version</span></span><br><span class="line">-&gt; <span class="keyword">decltype</span>(std::forward&lt;Container&gt;(c)[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">authenticateUser</span>();</span><br><span class="line"><span class="keyword">return</span> std::forward&lt;Container&gt;(c)[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>变量名是个左值，对一个变量名字使用 decltype，会得到该变量的 declared type。但对于比变量名字更复杂的<strong>左值表达式</strong>，decltype 总是会得到一个左值引用。比如下面的这个<strong>奇怪</strong>的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">f1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">…</span><br><span class="line"><span class="keyword">return</span> x; <span class="comment">// decltype(x) is int, so f1 returns int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">f2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">…</span><br><span class="line"><span class="keyword">return</span> (x); <span class="comment">// decltype((x)) is int&amp;, so f2 returns int&amp;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>x 是一个类型为 int 的变量名，所以 f1 是 int 类型的。但 (x) 是比名字更复杂的左值表达式，所以 f2 是 int &amp; 类型的。</p>
<p><strong>Things to Remember</strong></p>
<ul>
<li>decltype almost always yields the type of a variable or expression without any modifications.</li>
<li>For lvalue expressions of type T other than names, decltype always reports a type of T&amp;.</li>
<li>C++14 supports decltype(auto), which, like auto, deduces a type from its initializer, but it performs the type deduction using the decltype rules.</li>
</ul>
<h2 id="Item-4：如何观测实际的类型推断"><a href="#Item-4：如何观测实际的类型推断" class="headerlink" title="Item 4：如何观测实际的类型推断"></a>Item 4：如何观测实际的类型推断</h2><p>书中给出了三种方法：IDE 自动推断（getting type deduction information as you edit your code），编译中获取（getting it during compilation）和在运行中获取（getting it at runtime）。</p>
<p>Visual Studio 2015可以对相对简单的类型进行推断:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> theAnswer = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">auto</span> x = theAnswer;  <span class="comment">//把鼠标放在auto上就能看到推断的类型</span></span><br><span class="line"><span class="keyword">auto</span> y = &amp;theAnswer;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在代码编译时，若出现 error，会给出相关的信息，这也能得到推断的类型，如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">// declaration only for TD;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TD</span>;            <span class="comment">// TD == &quot;Type Displayer&quot;</span></span><br><span class="line">TD&lt;<span class="keyword">decltype</span>(x)&gt; xType; <span class="comment">// elicit errors containing</span></span><br><span class="line">TD&lt;<span class="keyword">decltype</span>(y)&gt; yType; <span class="comment">// x&#x27;s and y&#x27;s types</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由于TD并没有定义，会出现如下的错误：<br>error: aggregate ‘TD&lt;**int**&gt; xType’ has incomplete type and<br>       cannot be defined<br>error: aggregate ‘TD&lt;**const int ***&gt; yType’ has incomplete type<br>       and cannot be defineds</p>
<p>在函数运行时，你也可以使用函数typeid：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="built_in">typeid</span>(x).<span class="built_in">name</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; </span><br><span class="line">std::cout &lt;&lt; <span class="built_in">typeid</span>(*x).<span class="built_in">name</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然而，这些方法都或多或少有些问题，如VS中的类型推断可能不是很直白：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> std::_Simple_types&lt;std::_Wrap_alloc&lt;std::_Vec_base_types&lt;Widget,</span><br><span class="line">std::allocator&lt;Widget&gt; &gt;::_Alloc&gt;::value_type&gt;::value_type *</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>有个Boost TypeIndex library（<a target="_blank" rel="noopener" href="http://boost.com/">http://boost.com</a> )，可以在std::type_info::name 和 IDEs没那么好用的情况下使用。</p>
<p><strong>Things to Remember</strong></p>
<ul>
<li>Deduced types can often be seen using IDE editors, compiler error messages, and the Boost TypeIndex library.  </li>
<li>The results of some tools may be neither helpful nor accurate, so an understanding of C++’s type deduction rules remains essential.</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/10/Josephus-Permutation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wizlyk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wizlyk">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/08/10/Josephus-Permutation/" class="post-title-link" itemprop="url">Josephus Permutation</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-08-10 09:12:04" itemprop="dateCreated datePublished" datetime="2019-08-10T09:12:04+08:00">2019-08-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-29 20:38:11" itemprop="dateModified" datetime="2022-11-29T20:38:11+08:00">2022-11-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="约瑟夫问题"><a href="#约瑟夫问题" class="headerlink" title="约瑟夫问题"></a>约瑟夫问题</h1><p><code>维基百科</code></p>
<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p><strong>约瑟夫问题</strong>（有时也称为<strong>约瑟夫斯置换</strong>），是一个出现在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">计算机科学</a>和<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%A6">数学</a>中的问题。在计算机<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BC%96%E7%A8%8B">编程</a>的算法中，类似问题又称为<strong>约瑟夫环</strong>。</p>
<p>人们站在一个等待被处决的圈子里。 计数从圆圈中的指定点开始，并沿指定方向围绕圆圈进行。 在跳过指定数量的人之后，执行下一个人。 对剩下的人重复该过程，从下一个人开始，朝同一方向跳过相同数量的人，直到只剩下一个人，并被释放。</p>
<p>问题即，给定人数、起点、方向和要跳过的数字，选择初始圆圈中的位置以避免被处决。</p>
<h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>这个问题是以<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%BC%97%E6%8B%89%E7%B6%AD%E5%A5%A7%C2%B7%E7%B4%84%E7%91%9F%E5%A4%AB%E6%96%AF">弗拉维奥·约瑟夫</a>命名的，他是1世纪的一名犹太历史学家。他在自己的日记中写道，他和他的40个战友被罗马军队包围在洞中。他们讨论是自杀还是被俘，最终决定自杀，并以抽签的方式决定谁杀掉谁。约瑟夫斯和另外一个人是最后两个留下的人。约瑟夫斯说服了那个人，他们将向罗马军队投降，不再自杀。约瑟夫斯把他的存活归因于运气或天意，他不知道是哪一个。</p>
<hr>
<p><code>wizlyk</code></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这个问题的背景还是挺沉重的，但我们现在关心的是怎么解决这个问题。</p>
<p>约瑟夫环问题可以有很多种问法，比如找到一定次数后不会被出列的位置、给出出列的顺序、判断最后剩下的人的位置等等，接下来我们将对这些问题给出一个统一的解决方案。</p>
<p>问题：假设队列中一共有n个人，每次找到第m个人出列，然后从第m+1个人开始数，再找第m个人出列，直到队列里空无一人。求每次出列的人在原队列中的位置。</p>
<p>首先，直接从模拟操作入手，可以用链表或数组，每次移动一定的位置并做好标记（链表可以删除节点，数组可以做标记），然后每次输出找到的位置就行。对于链表，移动的总步数在 O(n*m)的量级，对于数组，移动的总步数在O(n^2)的量级。</p>
<p>上面的做法，判断最后一个剩下的人的位置需要O(n*m)的时间。但由于问题的规则已经非常清楚了，每一步操作后，下一步的状态已经确定，那么有没有O(n)的办法直接得到最后一个人的位置呢？</p>
<p>答案当然是有的。</p>
<p>要做到O(n)，首先要考虑每一步和其上一步的关系，只有能在O(1)的时间内得到转移的方式，才能实现O(n)的总体时间复杂度。</p>
<p>假设在倒数第i步，未出列的共i个人，第一个报数的人编号记为0（记为1也行，但在稍后的求余操作中会多出减1和加1的操作，不够简洁）。考虑在第m个人出列后，倒数第(i-1)步的编号变化。见下表。</p>
<table>
<thead>
<tr>
<th align="center">倒数第i步的编号</th>
<th align="center">倒数第(i-1)步的编号</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">i - m</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">i - m + 1</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">i - m +２</td>
</tr>
<tr>
<td align="center">…</td>
<td align="center">…</td>
</tr>
<tr>
<td align="center">m - 2</td>
<td align="center">i - 2</td>
</tr>
<tr>
<td align="center">m - 1 (出列位置)</td>
<td align="center">- (无)</td>
</tr>
<tr>
<td align="center">m</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">…</td>
<td align="center">…</td>
</tr>
<tr>
<td align="center">i - 1</td>
<td align="center">i - m - 1</td>
</tr>
</tbody></table>
<p>若记倒数第i步的第k个位置标号为 $f(i, k)$,则有</p>
<p>$$f(i,k) &#x3D; \big(f(i-1,k)+m\big) \mod i$$</p>
<p>这个公式告诉我们，当我们知道后面出列的人在其队列中的编号，我们可以推出他在<strong>出列前的编号</strong>。比如我们知道最后一个人出列时他的编号只能为0（因为队伍只有一个人），那么就可以一直推出最后出列的人在初始队列中的编号。</p>
<p>举个例子，n&#x3D;4，m&#x3D;3，求最后一次出列的人在队列中的编号。</p>
<table>
<thead>
<tr>
<th>倒数第i次（剩下i个人）</th>
<th>编号</th>
<th>计算公式</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>0</td>
<td>-</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>(0 + 3) % 2</td>
</tr>
<tr>
<td>3</td>
<td>1</td>
<td>(1 + 3) % 3</td>
</tr>
<tr>
<td>4</td>
<td>0</td>
<td>(1 + 3) % 4</td>
</tr>
</tbody></table>
<p>则可知最后一次出列的人编号为0。</p>
<p>那么如果我们想知道第k个出列的人是谁怎么办呢？可以知道，第k个出列的人出列前，队伍里剩下(n-k+1)个人，而他现在在队伍里的编号是 $(m-1) \mod (n-k+1)$。因此，我们可以用递归来求：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求第k次出列的人的编号</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">JosephusProblem</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">return</span> (m - <span class="number">1</span>) % n;</span><br><span class="line">  <span class="keyword">return</span> (<span class="built_in">JosephusProblem</span>(n - <span class="number">1</span>, m, k - <span class="number">1</span>) + m) % n ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用上递归后，程序非常的简洁。由于是尾递归，可以很容易地写成迭代的方式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ans = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">    ans = (ans + m) % (n - k + i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要求最后一个出列的人，只需要调用<code>JosephusProblem(n, m, n)</code> 就可以了。</p>
<p>有意思的是，虽然可以在O(k)的时间内找到第k个出列的人，但要用这种方法打印出整个出列序列，还是需要$1+2 + … +n &#x3D; O(n^2)$ 的时间复杂度。</p>
<p>留下的问题：</p>
<ul>
<li>能在 O(n) 的时间复杂度下打印出整个出列序列么？</li>
<li>或是说，是否存在 O(1) 的时间复杂度的算法，即一个数学公式，来求出第 k 个出列的人的编号？</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/09/Knapsack-Problem/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wizlyk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wizlyk">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/08/09/Knapsack-Problem/" class="post-title-link" itemprop="url">Knapsack Problem</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-08-09 13:24:02" itemprop="dateCreated datePublished" datetime="2019-08-09T13:24:02+08:00">2019-08-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-29 20:38:11" itemprop="dateModified" datetime="2022-11-29T20:38:11+08:00">2022-11-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Knapsack Problem 就是大名鼎鼎的“背包问题”，其中又以“01背包”为大家所熟知。</p>
<p>先来看一段来自维基百科的介绍：</p>
<hr>
<p><strong>背包问题</strong>（Knapsack problem）是一种<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BB%84%E5%90%88%E4%BC%98%E5%8C%96">组合优化</a>的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/NP%E5%AE%8C%E5%85%A8">NP完全</a>问题。问题可以描述为：给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。问题的名称来源于如何选择最合适的物品放置于给定背包中。</p>
<p>相似问题经常出现在商业、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6">组合数学</a>，<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E5%A4%8D%E6%9D%82%E6%80%A7%E7%90%86%E8%AE%BA">计算复杂性理论</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A0%81%E5%AD%A6">密码学</a>和<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E6%95%B0%E5%AD%A6">应用数学</a>等领域中。</p>
<p>也可以将背包问题描述为<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%B1%BA%E5%AE%9A%E6%80%A7%E5%95%8F%E9%A1%8C">决定性问题</a>，即在总重量不超过<em>W</em>的前提下，总价值是否能达到<em>V</em>。</p>
<p><strong>定义</strong></p>
<p>我们有 <em>n</em> 种物品，物品 <em>j</em> 的重量为$w_j$，价格为$p_j$。<br>我们假定所有物品的重量和价格都是非负的。背包所能承受的最大重量为<em>W</em>。<br>如果限定每种物品只能选择0个或1个，则问题称为<strong>0-1背包问题</strong>。</p>
<p>可以用公式表示为：<br>$$max: \sum_{j &#x3D; 1}^{n} p_ix_i$$<br>$$ s.t.: \sum_{j&#x3D;1}^n w_ix_i \leqslant W, x_j \in {0,1}$$</p>
<p>如果限定物品 j 最多只能选择 $b_j$个，则问题称为<strong>有界背包问题</strong></p>
<p>可以用公式表示为：<br>$$max: \sum_{j &#x3D; 1}^{n} p_ix_i$$<br>$$ s.t.: \sum_{j&#x3D;1}^n w_ix_i \leqslant W, x_j \in {0,1,…,b_j}$$</p>
<p>如果不限定每种物品的数量，则问题称为<strong>无界背包问题</strong>。</p>
<p>各类复杂的背包问题总可以变化为简单的0-1背包问题进行求解。</p>
<p><strong>计算复杂度</strong></p>
<p>在计算机科学领域，人们对背包问题感兴趣的原因在于：</p>
<ul>
<li>利用<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">动态规划</a>，背包问题存在一个<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BC%AA%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%97%B6%E9%97%B4">伪多项式时间</a>算法</li>
<li>把上面算法作为子程序，背包问题存在完全逼近多项式时间方案</li>
<li>作为<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/NP%E5%AE%8C%E5%85%A8">NP完全</a>问题，背包问题没有一种既准确又快速（多项式时间）的算法</li>
</ul>
<hr>
<p>背包问题在我们的生活中是那么的常见（在面试题中也一样），直白的问题和经典的动态规划解法，使得背包问题显得那么重要而基础。</p>
<p>先来看来自于左程云的《程序员代码面试指南》中的例子</p>
<p><strong>1. 换钱的最少货币数 I</strong></p>
<p>给定货币面值，存放于 <code>cash</code> 数组中。求对于指定的钱数 <code>aim</code>， 最少需要几张货币。若不能换，则返回-1。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">cash = &#123;2,3,5&#125;, aim = 20</span><br><span class="line">Output:</span><br><span class="line">20</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">cash = &#123;2,3,5&#125;, aim = 0</span><br><span class="line">Output:</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">cash = &#123;2&#125;, aim = 1</span><br><span class="line">Output:</span><br><span class="line">-1</span><br></pre></td></tr></table></figure>

<p>由于每个面值的货币都可以使用无数次（即<strong>无界背包问题</strong>），所以对于每一个面值的货币，我们都可以从最小的钱数开始，每次判断这个数减去面值后所需要的货币数，同时更新该钱数需要的最少货币数。</p>
<p>即转移公式为： </p>
<p>$$dp[k] &#x3D; min(dp[k], dp[k-cash[i]]+ 1)$$</p>
<p>如若输入为<code>cash = &#123;2,5&#125;, aim = 6 </code>:<br>最开始时，面值为2的货币，钱为2需要1张，3不行，4需要2张，5不行，6需要3张<br>然后面值为5的货币，则钱为5需要1张，6需要2张，这个时候就更新6元的货币数，从3改为2。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minCash</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;cash, <span class="type">int</span> aim)</span> </span>&#123;</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(aim + <span class="number">1</span>, <span class="number">-1</span>)</span></span>;  <span class="comment">// 用于记录最小钱数的数组，是动态规划的基础结构</span></span><br><span class="line">  dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> n = cash.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123; <span class="comment">// 对于第i种货币</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> sum = cash[i]; sum &lt;= aim; ++sum) &#123;</span><br><span class="line">      <span class="type">int</span> last = sum - cash[i];</span><br><span class="line">      <span class="keyword">if</span> (dp[last] == <span class="number">0</span>) &#123;  <span class="comment">// last == 0 的情况</span></span><br><span class="line">        dp[sum] = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (dp[last] == <span class="number">-1</span>)  <span class="comment">// 不能从前一个数中到达sum</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 判断是否需要更新</span></span><br><span class="line">        dp[sum] = (dp[sum] == <span class="number">-1</span> ? dp[last] + <span class="number">1</span> : <span class="built_in">min</span>(dp[sum], dp[last] + <span class="number">1</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[aim];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的例题是货币可以无限取，当只能有限取（即<strong>有界背包问题</strong>）时，又改怎么变化呢？</p>
<p>再来个例子：</p>
<p><strong>2.  换钱的最少货币数 II</strong></p>
<p>给定你现在有的钱数，存放于 <code>cash</code> 数组中。求对于指定的钱数 <code>aim</code>， 最少需要几张货币。若不能换（或钱不够），则返回 -1。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">cash = &#123;2,3,5&#125;, aim = 20</span><br><span class="line">Output:</span><br><span class="line">-1</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">cash = &#123;5,2,3,5&#125;, aim = 10</span><br><span class="line">Output:</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">cash = &#123;2&#125;, aim = 0</span><br><span class="line">Output:</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>其实解答的思路和上个例子一模一样，也是用一个数组来存放已经计算好的最少需要的货币数。唯一的不同在于，我们的钱只能用一次，很现实。</p>
<p>注意在上一个例子中，我们重复使用钱的关键在于这一句:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> sum = cash[i]; sum &lt;= aim; ++sum)</span><br></pre></td></tr></table></figure>

<p>即我们是从小加到大，从而保证了使用某货币<code>c</code>时，大的钱数<code>sum</code>可以由小的钱数<code>sum-c</code>那跳转，而<code>sum-c</code>我们已经计算过了，所以大的钱数<code>sum</code>可以重复使用该货币。</p>
<p>那么如果要让钱不能重复使用，我们就从大往小算就行了，这样，每次计算，前面的最小货币数必定是没有使用当前货币的情况。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minCash</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;cash, <span class="type">int</span> aim)</span> </span>&#123;</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(aim + <span class="number">1</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">  dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> n = cash.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> sum = aim; sum &gt;= cash[i]; --sum)&#123;  <span class="comment">// 从大到小算</span></span><br><span class="line">      <span class="type">int</span> last = sum - cash[i];</span><br><span class="line">      <span class="keyword">if</span> (dp[last] == <span class="number">0</span>) &#123;</span><br><span class="line">        dp[sum] = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (dp[last] == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        dp[sum] = (dp[sum] == <span class="number">-1</span> ? dp[last] + <span class="number">1</span> : <span class="built_in">min</span>(dp[sum], dp[last] + <span class="number">1</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[aim];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看，其实差距只有一行。</p>
<p><strong>3. 换钱的方法数</strong></p>
<p>假定你现在有面值不同的货币，存放在 <code>cash</code> 数组中，每种货币可以用无数次。求对于一个给定的钱数 <code>aim</code> ，有多少中换钱的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">cash = &#123;1,10,25,5&#125;, aim = 15</span><br><span class="line">Output:</span><br><span class="line">6</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">cash = &#123;5,2,3,5&#125;, aim = 1</span><br><span class="line">Output:</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>题目和第一个例子很相似，不同之处在于求解的目标不一样，所以我们动态规划使用的 <code>dp</code> 数组的含义也不一样。</p>
<p>对于例子“换钱的最少货币数 I”， <code>dp</code> 数组的含义是当前状态下，每个数需要的最少货币数；<br>对于例子“换钱的方法数”， <code>dp</code> 数组的含义是当前状态下，每个数对应的换钱方法数。</p>
<p>转移公式：</p>
<p>$$dp[k] &#x3D; dp[k]+dp[k-cach[i]]$$</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">countChanges</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;cash, <span class="type">int</span> aim)</span> </span>&#123;</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(aim + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">  dp[<span class="number">0</span>] = <span class="number">-1</span>;  <span class="comment">// 0 之所以特殊，是因为任何面值都可以从0开始计算</span></span><br><span class="line">  <span class="type">int</span> n = cash.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> sum = cash[i]; sum &lt;= aim; ++sum) &#123;</span><br><span class="line">      <span class="type">int</span> last = sum - cash[i];</span><br><span class="line">      <span class="keyword">if</span> (dp[last] == <span class="number">-1</span>)  <span class="comment">// 即 ++dp[cash[i]] </span></span><br><span class="line">        dp[sum]++;  </span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (dp[last] == <span class="number">0</span>)  <span class="comment">// 换不了，那可咋办嘛？答，continue</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">else</span> </span><br><span class="line">        dp[sum] += dp[last];  <span class="comment">// 加上前面那个数能换的方法数</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[aim];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里的转移公式和经典的<a target="_blank" rel="noopener" href="https://leetcode.com/problems/climbing-stairs/">爬梯子问题</a>很像。</p>
<p>讲的很浅，以后有机会再补充例子。</p>
<p>最后再用一道实际的腾讯笔试题来结尾吧。</p>
<p><strong>数字拼凑</strong><br>小Q有一个长度为n的序列S，序列中有n个正整数。小Q现在和你玩数字游戏，每次小Q说出一个正整数X，你需要从序列中挑选出若干个数字出来进行相加，使结果等于X，如果你不能完成拼凑你就输了。</p>
<p>小Q现在想知道能让你输掉游戏的最小的正整数X是多少？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入描述：</span><br><span class="line">输入包括两行</span><br><span class="line">第一行为一个正整数n，表示序列的长度 1 &lt;= n &lt;= 20</span><br><span class="line">第二行包括n个正整数a[i]，用空格隔开， 1 &lt;= a[i] &lt; 10^5</span><br><span class="line"></span><br><span class="line">输出描述：</span><br><span class="line">一个正整数，表示最小的正整数X</span><br><span class="line"></span><br><span class="line">示例1：</span><br><span class="line">输入：</span><br><span class="line">3</span><br><span class="line">2 1 4</span><br><span class="line">输出：</span><br><span class="line">8</span><br></pre></td></tr></table></figure>






























      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/20/OH-MY-DEAR/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wizlyk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wizlyk">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/02/20/OH-MY-DEAR/" class="post-title-link" itemprop="url">Jacobian</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-02-20 14:16:16" itemprop="dateCreated datePublished" datetime="2019-02-20T14:16:16+08:00">2019-02-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-29 20:38:11" itemprop="dateModified" datetime="2022-11-29T20:38:11+08:00">2022-11-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Jacobian"><a href="#Jacobian" class="headerlink" title="Jacobian"></a>Jacobian</h2><p>发现一个以前没注意的问题，Jacobian行列式之所以要求取绝对值，是因为不同的坐标顺序会导致不同的行列式值（如下图），而我们通常希望得到一个正的数，所以要取绝对值。</p>
<p><img src="/2019/02/20/OH-MY-DEAR/Jacobian.jpg" alt="不同的坐标顺序去表换到相同的坐标系 https://math.stackexchange.com/questions/1144214/on-the-jacobian-determinant-for-conversion-to-cylindrical-coordinates"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">wizlyk</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">8</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wizlyk</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
