<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="本文所有内容参考于 《Effective Modern C++》（Scott Meyers）一书，仅供个人学习 Moving to Modern C++Item 7:辨别生成对象时()和{}的不同当一个类没有以 initializer_list 为参数的构造函数时，使用()和{}并无二致： 12345678910class Widget &amp;#123;public:  Widget(int i, b">
<meta property="og:type" content="article">
<meta property="og:title" content="Moving to Modern C++ - 《Effective Modern C++》阅读笔记（三）">
<meta property="og:url" content="http://yoursite.com/2019/08/11/EMC-notes-3/index.html">
<meta property="og:site_name" content="wizlyk">
<meta property="og:description" content="本文所有内容参考于 《Effective Modern C++》（Scott Meyers）一书，仅供个人学习 Moving to Modern C++Item 7:辨别生成对象时()和{}的不同当一个类没有以 initializer_list 为参数的构造函数时，使用()和{}并无二致： 12345678910class Widget &amp;#123;public:  Widget(int i, b">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2019-08-11T01:50:15.000Z">
<meta property="article:modified_time" content="2022-11-29T12:38:11.767Z">
<meta property="article:author" content="wizlyk">
<meta property="article:tag" content="Effective Modern C++">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2019/08/11/EMC-notes-3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Moving to Modern C++ - 《Effective Modern C++》阅读笔记（三） | wizlyk</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">wizlyk</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">wizlyk的代码小天地</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/11/EMC-notes-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wizlyk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wizlyk">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Moving to Modern C++ - 《Effective Modern C++》阅读笔记（三）
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-08-11 09:50:15" itemprop="dateCreated datePublished" datetime="2019-08-11T09:50:15+08:00">2019-08-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-29 20:38:11" itemprop="dateModified" datetime="2022-11-29T20:38:11+08:00">2022-11-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><code>本文所有内容参考于 《Effective Modern C++》（Scott Meyers）一书，仅供个人学习</code></p>
<h1 id="Moving-to-Modern-C"><a href="#Moving-to-Modern-C" class="headerlink" title="Moving to Modern C++"></a>Moving to Modern C++</h1><h2 id="Item-7-辨别生成对象时-和-的不同"><a href="#Item-7-辨别生成对象时-和-的不同" class="headerlink" title="Item 7:辨别生成对象时()和{}的不同"></a>Item 7:辨别生成对象时()和{}的不同</h2><p>当一个类没有以 initializer_list 为参数的构造函数时，使用()和{}并无二致：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Widget</span>(<span class="type">int</span> i, <span class="type">bool</span> b); <span class="comment">// ctors not declaring</span></span><br><span class="line">  <span class="built_in">Widget</span>(<span class="type">int</span> i, <span class="type">double</span> d); <span class="comment">// std::initializer_list params</span></span><br><span class="line">…</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Widget <span class="title">w1</span><span class="params">(<span class="number">10</span>, <span class="literal">true</span>)</span></span>; <span class="comment">// calls first ctor</span></span><br><span class="line">Widget w2&#123;<span class="number">10</span>, <span class="literal">true</span>&#125;; <span class="comment">// also calls first ctor</span></span><br><span class="line"><span class="function">Widget <span class="title">w3</span><span class="params">(<span class="number">10</span>, <span class="number">5.0</span>)</span></span>; <span class="comment">// calls second ctor</span></span><br><span class="line">Widget w4&#123;<span class="number">10</span>, <span class="number">5.0</span>&#125;; <span class="comment">// also calls second ctor</span></span><br></pre></td></tr></table></figure>

<p>但若有了以 initializer_list 为参数的构造函数，使用{}会优先匹配对应的构造函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Widget</span>(<span class="type">int</span> i, <span class="type">bool</span> b); <span class="comment">// as before</span></span><br><span class="line">  <span class="built_in">Widget</span>(<span class="type">int</span> i, <span class="type">double</span> d); <span class="comment">// as before</span></span><br><span class="line">  <span class="built_in">Widget</span>(std::initializer_list&lt;<span class="type">long</span> <span class="type">double</span>&gt; il); <span class="comment">// added</span></span><br><span class="line">…</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Widget <span class="title">w1</span><span class="params">(<span class="number">10</span>, <span class="literal">true</span>)</span></span>; <span class="comment">// uses parens and, as before,</span></span><br><span class="line">                     <span class="comment">// calls first ctor</span></span><br><span class="line">Widget w2&#123;<span class="number">10</span>, <span class="literal">true</span>&#125;; <span class="comment">// uses braces, but now calls</span></span><br><span class="line">                     <span class="comment">// std::initializer_list ctor</span></span><br><span class="line">                     <span class="comment">// (10 and true convert to long double)</span></span><br><span class="line"><span class="function">Widget <span class="title">w3</span><span class="params">(<span class="number">10</span>, <span class="number">5.0</span>)</span></span>; <span class="comment">// uses parens and, as before,</span></span><br><span class="line">                    <span class="comment">// calls second ctor</span></span><br><span class="line">Widget w4&#123;<span class="number">10</span>, <span class="number">5.0</span>&#125;; <span class="comment">// uses braces, but now calls</span></span><br><span class="line">                    <span class="comment">// std::initializer_list ctor</span></span><br><span class="line">                    <span class="comment">// (10 and 5.0 convert to long double)</span></span><br></pre></td></tr></table></figure>

<p>这里可以看到，true 和 10 等都被隐式类型转换成了 long double，可见 initializer_list 的构造函数的优先级非常高。<br>它的优先级甚至高于了移动构造函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Widget</span>(<span class="type">int</span> i, <span class="type">bool</span> b); <span class="comment">// as before</span></span><br><span class="line">	<span class="built_in">Widget</span>(<span class="type">int</span> i, <span class="type">double</span> d); <span class="comment">// as before</span></span><br><span class="line">	<span class="built_in">Widget</span>(std::initializer_list&lt;<span class="type">long</span> <span class="type">double</span>&gt; il); <span class="comment">// as before</span></span><br><span class="line">	<span class="function"><span class="keyword">operator</span> <span class="title">float</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// convert</span></span><br><span class="line">	… <span class="comment">// to float</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Widget <span class="title">w5</span><span class="params">(w4)</span></span>; <span class="comment">// uses parens, calls copy ctor</span></span><br><span class="line">Widget w6&#123;w4&#125;; <span class="comment">// uses braces, calls</span></span><br><span class="line">               <span class="comment">// std::initializer_list ctor</span></span><br><span class="line">               <span class="comment">// (w4 converts to float, and float</span></span><br><span class="line">               <span class="comment">// converts to long double)</span></span><br><span class="line"><span class="function">Widget <span class="title">w7</span><span class="params">(std::move(w4))</span></span>; <span class="comment">// uses parens, calls move ctor</span></span><br><span class="line">Widget w8&#123;std::<span class="built_in">move</span>(w4)&#125;; <span class="comment">// uses braces, calls</span></span><br><span class="line">                          <span class="comment">// std::initializer_list ctor</span></span><br><span class="line">                          <span class="comment">// (for same reason as w6)</span></span><br></pre></td></tr></table></figure>

<p><strong>待编辑：说实话，这里并不太懂，w4会直接使用operator()?</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Widget</span>(<span class="type">int</span> i, <span class="type">bool</span> b); <span class="comment">// as before</span></span><br><span class="line">  <span class="built_in">Widget</span>(<span class="type">int</span> i, <span class="type">double</span> d); <span class="comment">// as before</span></span><br><span class="line">  <span class="built_in">Widget</span>(std::initializer_list&lt;<span class="type">bool</span>&gt; il); <span class="comment">// element type is</span></span><br><span class="line">                                          <span class="comment">// now bool</span></span><br><span class="line">  … <span class="comment">// no implicit</span></span><br><span class="line">&#125;; <span class="comment">// conversion funcs</span></span><br><span class="line"></span><br><span class="line">Widget w&#123;<span class="number">10</span>, <span class="number">5.0</span>&#125;; <span class="comment">// error! requires narrowing conversions</span></span><br></pre></td></tr></table></figure>

<p>从上面这例可以看出，编译器非常倾向于使用 std::initializer_list 的构造函数，从而使得正确匹配参数的构造函数并不会被使用。另外还有个小知识点：{}初始器中，缩小范围的隐式类型转换会报错。<br>只有在无法进行类型转换的情况下，编译器才会考虑其他的构造函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Widget</span>(<span class="type">int</span> i, <span class="type">bool</span> b); <span class="comment">// as before</span></span><br><span class="line">  <span class="built_in">Widget</span>(<span class="type">int</span> i, <span class="type">double</span> d); <span class="comment">// as before</span></span><br><span class="line"><span class="comment">// std::initializer_list element type is now std::string</span></span><br><span class="line">  <span class="built_in">Widget</span>(std::initializer_list&lt;std::string&gt; il);</span><br><span class="line">  … <span class="comment">// no implicit</span></span><br><span class="line">&#125;; <span class="comment">// conversion funcs</span></span><br><span class="line"></span><br><span class="line"><span class="function">Widget <span class="title">w1</span><span class="params">(<span class="number">10</span>, <span class="literal">true</span>)</span></span>; <span class="comment">// uses parens, still calls first ctor</span></span><br><span class="line">Widget w2&#123;<span class="number">10</span>, <span class="literal">true</span>&#125;; <span class="comment">// uses braces, now calls first ctor</span></span><br><span class="line"><span class="function">Widget <span class="title">w3</span><span class="params">(<span class="number">10</span>, <span class="number">5.0</span>)</span></span>; <span class="comment">// uses parens, still calls second ctor</span></span><br><span class="line">Widget w4&#123;<span class="number">10</span>, <span class="number">5.0</span>&#125;; <span class="comment">// uses braces, now calls second ctor</span></span><br></pre></td></tr></table></figure>

<p>那么，当初始化是使用空的 {} 会怎么样呢？是空的 initializer_list 还是调用默认构造函数？结论是<strong>调用默认构造函数</strong>。当然了，如果你想使用空的 ()，那会变成调用一个对应名字的函数了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Widget</span>(); <span class="comment">// default ctor</span></span><br><span class="line">  <span class="built_in">Widget</span>(std::initializer_list&lt;<span class="type">int</span>&gt; il); <span class="comment">// std::initializer_list ctor</span></span><br><span class="line">  … <span class="comment">// no implicit</span></span><br><span class="line">&#125;; <span class="comment">// conversion funcs</span></span><br><span class="line"></span><br><span class="line">Widget w1; <span class="comment">// calls default ctor</span></span><br><span class="line">Widget w2&#123;&#125;; <span class="comment">// also calls default ctor</span></span><br><span class="line"><span class="function">Widget <span class="title">w3</span><span class="params">()</span></span>; <span class="comment">// most vexing parse! declares a function!</span></span><br></pre></td></tr></table></figure>

<p>如果真的想调用空的 initializer_list，需要两重括号：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">w4</span><span class="params">(&#123;&#125;)</span></span>; <span class="comment">// calls std::initializer_list ctor</span></span><br><span class="line">               <span class="comment">// with empty list</span></span><br><span class="line">Widget w5&#123;&#123;&#125;&#125;; <span class="comment">// ditto</span></span><br></pre></td></tr></table></figure>

<p>对于模板编写者来说，若想自己定义对于 () 中参数的反应，可以像如下代码这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="comment">// type of object to create</span></span><br><span class="line">	<span class="keyword">typename</span>... Ts&gt; <span class="comment">// types of arguments to use</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomeWork</span><span class="params">(Ts&amp;&amp;... params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">T <span class="title">localObject1</span><span class="params">(std::forward&lt;Ts&gt;(params)...)</span></span>; <span class="comment">// using parens  </span></span><br><span class="line">  <span class="comment">// 或者像下面这样</span></span><br><span class="line">  T localObject2&#123;std::forward&lt;Ts&gt;(params)...&#125;; <span class="comment">// using braces</span></span><br><span class="line">…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，对于下面的代码，localObject1 会是一个由10个元素组成的 vector，而 localObject2 是由2个元素组成的 vector。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doSomeWork&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;(<span class="number">10</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<p><strong>Things to Remember</strong></p>
<ul>
<li>Braced initialization is the most widely usable initialization syntax, it prevents narrowing conversions, and it’s immune to C++’s most vexing parse. </li>
<li>During constructor overload resolution, braced initializers are matched to std::initializer_list parameters if at all possible, even if other constructors offer seemingly better matches.</li>
<li>An example of where the choice between parentheses and braces can make a significant difference is creating a std::vector&lt;numeric type&gt; with two arguments.</li>
<li>Choosing between parentheses and braces for object creation inside templates can be challenging.</li>
</ul>
<h2 id="Item-8-多用-nullptr-代替-0-和-null"><a href="#Item-8-多用-nullptr-代替-0-和-null" class="headerlink" title="Item 8:多用 nullptr 代替 0 和 null"></a>Item 8:多用 nullptr 代替 0 和 null</h2><p>当 C++ 发现一个需要用指针的地方出现了0时，它通常会把0看作是一个空指针。然而，C++主要的原则还是将0看作是一个int。NULL 也类似，编译允许在一些情况下将 NULL 当成一个整数（如 long）。<br>在 C++98 中，使用0和 NULL 的重载可能会有一些意外：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>)</span></span>; <span class="comment">// three overloads of f</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">bool</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">void</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(<span class="number">0</span>); <span class="comment">// calls f(int), not f(void*)</span></span><br><span class="line"><span class="built_in">f</span>(<span class="literal">NULL</span>); <span class="comment">// might not compile, but typically calls</span></span><br><span class="line">         <span class="comment">// f(int). Never calls f(void*)</span></span><br></pre></td></tr></table></figure>

<p>如果 NULL 的定义是 0L，那么编译的结果可能是模糊的，因为从 long 到 int 和从 0L 到 void* 是同样优先的。<br>所以，之所以推荐使用 nullptr，就是因为 nullptr 没有 int 类型，从而可以把它看成是一个可以代表所有类型的空指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">f</span>(<span class="literal">nullptr</span>); <span class="comment">// calls f(void*) overload</span></span><br></pre></td></tr></table></figure>

<p>在 cppreference 网站上找到个有意思的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F, <span class="keyword">class</span> A&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Fwd</span><span class="params">(F f, A a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(<span class="type">int</span>* i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Function g called\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">g</span>(<span class="literal">NULL</span>);           <span class="comment">// Fine</span></span><br><span class="line">    <span class="built_in">g</span>(<span class="number">0</span>);              <span class="comment">// Fine</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">Fwd</span>(g, <span class="literal">nullptr</span>);   <span class="comment">// Fine</span></span><br><span class="line"><span class="comment">//  Fwd(g, NULL);  // ERROR: No function g(int)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子有意思在哪呢？可以知道，如果单纯的调用函数 g:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">g</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">g</span>(<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p>是不会出错的，0 和 NULL 都被转换成了空指针；然而模板中 0 和 NULL 都被推断为 int 类型，从而导致了错误。这种错误排查起来可是很令人头疼的。</p>
<p><strong>Things to Remember</strong></p>
<ul>
<li>Prefer nullptr to 0 and NULL.</li>
<li>Avoid overloading on integral and pointer types.</li>
</ul>
<h2 id="Item-9-多用-alias-declarations-而不是-typedefs"><a href="#Item-9-多用-alias-declarations-而不是-typedefs" class="headerlink" title="Item 9:多用 alias declarations 而不是 typedefs"></a>Item 9:多用 alias declarations 而不是 typedefs</h2><p>当定义较长且常用时，C++11 以前一般用 typedef 来简化代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::unique_ptr&lt;std::unordered_map&lt;std::string, std::string&gt;&gt; UPtrMapSS;</span><br></pre></td></tr></table></figure>

<p>C++11 提供了 alias declarations：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UPtrMapSS = std::unique_ptr&lt;std::unordered_map&lt;std::string, std::string&gt;&gt;;</span><br></pre></td></tr></table></figure>

<p>他们俩提供了相同的作用。那么为什么还提倡使用 alias declarations 呢？首先 alias declarations 在涉及到函数指针时更直观：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FP is a synonym for a pointer to a function taking an int and</span></span><br><span class="line"><span class="comment">// a const std::string&amp; and returning nothing</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*FP)</span><span class="params">(<span class="type">int</span>, <span class="type">const</span> std::string&amp;)</span></span>; <span class="comment">// typedef</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// same meaning as above</span></span><br><span class="line"><span class="keyword">using</span> FP = <span class="built_in">void</span> (*)(<span class="type">int</span>, <span class="type">const</span> std::string&amp;); <span class="comment">// alias declaration</span></span><br></pre></td></tr></table></figure>

<p>其次， alias declarations 可以模板化，而 typedef 不能：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">// MyAllocList&lt;T&gt;</span></span><br><span class="line"><span class="keyword">using</span> MyAllocList = std::list&lt;T, MyAlloc&lt;T&gt;&gt;; <span class="comment">// is synonym for std::list&lt;T, MyAlloc&lt;T&gt;&gt;</span></span><br><span class="line">MyAllocList&lt;Widget&gt; lw; <span class="comment">// client code</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">// MyAllocList&lt;T&gt;::type</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyAllocList</span> &#123;                     <span class="comment">// is synonym for</span></span><br><span class="line">  <span class="keyword">typedef</span> std::list&lt;T, MyAlloc&lt;T&gt;&gt; type; <span class="comment">// std::list&lt;T,</span></span><br><span class="line">&#125;;                                       <span class="comment">// MyAlloc&lt;T&gt;&gt;</span></span><br><span class="line">MyAllocList&lt;Widget&gt;::type lw; <span class="comment">// client code</span></span><br></pre></td></tr></table></figure>

<p>当使用 typedef 时，如果我们想用 MyAllocList 在模板里创建一个对象，需要使用 typename:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123; <span class="comment">// Widget&lt;T&gt; contains</span></span><br><span class="line"><span class="keyword">private</span>: <span class="comment">// a MyAllocList&lt;T&gt;</span></span><br><span class="line">  <span class="keyword">typename</span> MyAllocList&lt;T&gt;::type list; <span class="comment">// as a data member</span></span><br><span class="line">…</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这里，MyAllocList&lt;T&gt;::type 是一个依赖于参数T的依赖类型(dependent type)，而C++要求依赖类型必须使用 typename。<br>而若是使用 alias template，代码会明快很多：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> MyAllocList = std::list&lt;T, MyAlloc&lt;T&gt;&gt;; <span class="comment">// as before</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  MyAllocList&lt;T&gt; list; <span class="comment">// no &quot;typename&quot;,</span></span><br><span class="line">… <span class="comment">// no &quot;::type&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>之所以会这样，是因为使用 alias template 的 MyAllocList<T> 必定是一个类型，而使用 typedef 的 MyAllocList<T>::type 并不一定是类型，所以后者需要使用 typename 来保证编译不会出错。作者在这顺带吐槽了一下：“That sounds<br>crazy, but don’t blame compilers for this possibility. It’s the humans who have been<br>known to produce such code.”</T></T></p>
<p>在 C++11 中，有个叫 type_traits 的标准库，提供了允许用户得到不同的参数类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::remove_const&lt;T&gt;::type <span class="comment">// yields T from const T</span></span><br><span class="line">std::remove_reference&lt;T&gt;::type <span class="comment">// yields T from T&amp; and T&amp;&amp;</span></span><br><span class="line">std::add_lvalue_reference&lt;T&gt;::type <span class="comment">// yields T&amp; from T</span></span><br></pre></td></tr></table></figure>

<p>注意这里都使用了 ::type。没错，这是 C++11 的，之所以不用 alias template 是由于一些历史原因。在 C++14 中，alias template 的 type_traits 也被加上了:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::remove_const&lt;T&gt;::type <span class="comment">// C++11: const T → T</span></span><br><span class="line">std::<span class="type">remove_const_t</span>&lt;T&gt; <span class="comment">// C++14 equivalent</span></span><br><span class="line">std::remove_reference&lt;T&gt;::type <span class="comment">// C++11: T&amp;/T&amp;&amp; → T</span></span><br><span class="line">std::<span class="type">remove_reference_t</span>&lt;T&gt; <span class="comment">// C++14 equivalent</span></span><br><span class="line">std::add_lvalue_reference&lt;T&gt;::type <span class="comment">// C++11: T → T&amp;</span></span><br><span class="line">std::<span class="type">add_lvalue_reference_t</span>&lt;T&gt; <span class="comment">// C++14 equivalent</span></span><br></pre></td></tr></table></figure>

<p>“The C++11 constructs remain valid in C++14, but I don’t know why you’d want to use them.”</p>
<p>当然了，如果你想自己实现 C++14 类似的 alias templates，可以像下面这样做：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="type">remove_const_t</span> = <span class="keyword">typename</span> remove_const&lt;T&gt;::type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="type">remove_reference_t</span> = <span class="keyword">typename</span> remove_reference&lt;T&gt;::type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="type">add_lvalue_reference_t</span> = <span class="keyword">typename</span> add_lvalue_reference&lt;T&gt;::type;</span><br></pre></td></tr></table></figure>

<p><strong>Things to Remember</strong></p>
<ul>
<li>typedefs don’t support templatization, but alias declarations do.</li>
<li>Alias templates avoid the “::type” suffix and, in templates, the “typename” prefix often required to refer to typedefs.</li>
<li>C++14 offers alias templates for all the C++11 type traits transformations.</li>
</ul>
<h2 id="Item-10-多用-scoped-enums-而不是-unscoped-enums"><a href="#Item-10-多用-scoped-enums-而不是-unscoped-enums" class="headerlink" title="Item 10:多用 scoped enums 而不是 unscoped enums"></a>Item 10:多用 scoped enums 而不是 unscoped enums</h2><p>在 C++98 有 enum 类型，它的用法是这样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123; black, white, red &#125;;</span><br></pre></td></tr></table></figure>

<p>然而这样使用会有隐患，比如若在这个定义的下面加上这样一句，就会出错：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> white = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>这是由于 enum 里面的变量是包括在整个和 Color 一样的参数空间里的，即 Color 在哪有效，这些 black 等就在哪有效。 这样的范围没有被限制的 enums 被称作 unscoped enums。 为了避免这种隐患，C++11 引入了 scoped enums:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span> &#123; black, white, red &#125;; <span class="comment">// black, white, red</span></span><br><span class="line">                                        <span class="comment">// are scoped to Color</span></span><br><span class="line"><span class="keyword">auto</span> white = <span class="literal">false</span>; <span class="comment">// fine, no other &quot;white&quot; in scope</span></span><br><span class="line">Color c = white; <span class="comment">// error! no enumerator named</span></span><br><span class="line">                 <span class="comment">// &quot;white&quot; is in this scope</span></span><br><span class="line">Color c = Color::white; <span class="comment">// fine</span></span><br><span class="line"><span class="keyword">auto</span> c = Color::white; <span class="comment">// also fine (and in accord</span></span><br><span class="line">                       <span class="comment">// with Item 5&#x27;s advice)</span></span><br></pre></td></tr></table></figure>

<p>Scoped enums 也被称为 enum classes。<br>除了作用范围以外，unscoped enums 和 scoped enums 还有类型转换上的差距：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123; black, white, red &#125;; <span class="comment">// unscoped enum</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">size_t</span>&gt; <span class="title">primeFactors</span><span class="params">(<span class="type">size_t</span> x)</span></span>;</span><br><span class="line">Color c = red;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (c &lt; <span class="number">14.5</span>) &#123; <span class="comment">// compare Color to double (!)</span></span><br><span class="line">  <span class="keyword">auto</span> factors = <span class="built_in">primeFactors</span>(c);<span class="comment">// compute prime factors of a Color (!)</span></span><br><span class="line">…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 unscoped enums 里面的 enumerators 是被隐式转换为整数类型的，所以上面的代码不会出错。但是 scoped enums 是没有这种隐式类型转换的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span> &#123; black, white, red &#125;; <span class="comment">// enum is now scoped</span></span><br><span class="line">Color c = Color::red; <span class="comment">// as before, but</span></span><br><span class="line">…                     <span class="comment">// with scope qualifier</span></span><br><span class="line"><span class="keyword">if</span> (c &lt; <span class="number">14.5</span>) &#123; <span class="comment">// error! can&#x27;t compare</span></span><br><span class="line">                <span class="comment">// Color and double</span></span><br><span class="line">  <span class="keyword">auto</span> factors = <span class="built_in">primeFactors</span>(c); <span class="comment">// error! can&#x27;t pass Color to</span></span><br><span class="line">                                  <span class="comment">// function expecting std::size_t</span></span><br><span class="line">…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若真的想用，得用显示类型转换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(c) &lt; <span class="number">14.5</span>) &#123; <span class="comment">// odd code, but</span></span><br><span class="line">                                     <span class="comment">// it&#x27;s valid</span></span><br><span class="line">  <span class="keyword">auto</span> factors = <span class="built_in">primeFactors</span>(<span class="built_in">static_cast</span>&lt;std::<span class="type">size_t</span>&gt;(c)); <span class="comment">// suspect, but it compiles</span></span><br><span class="line">…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 C++98，是不允许 enum 提前声明(forward-declared)的，因为编译器要根据 enum 里面 enumerators 的数量来决定用什么类型来表示这个 enum，从而提高程序的<strong>空间使用效率&#x2F;运行速度</strong>。在 C++11 中允许了 forward-declared，这是因为 C++11 默认了 enumerators 的类型。想自己修改也行：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Status</span>; <span class="comment">// underlying type is int</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Status</span>: std::<span class="type">uint32_t</span>; <span class="comment">// underlying type for</span></span><br><span class="line">                                  <span class="comment">// Status is std::uint32_t</span></span><br><span class="line">                                  <span class="comment">// (from &lt;cstdint&gt;)</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Status</span>: std::<span class="type">uint32_t</span> &#123; </span><br><span class="line">	good = <span class="number">0</span>,</span><br><span class="line">  failed = <span class="number">1</span>,</span><br><span class="line">  incomplete = <span class="number">100</span>,</span><br><span class="line">  corrupt = <span class="number">200</span>,</span><br><span class="line">  audited = <span class="number">500</span>,</span><br><span class="line">  indeterminate = <span class="number">0xFFFFFFFF</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span>: std::<span class="type">uint8_t</span>;</span><br></pre></td></tr></table></figure>

<p>unscoped enums 也不是一无是处，它 space leaking 的特点也具有一定的价值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UserInfo =          <span class="comment">// type alias; see Item 9</span></span><br><span class="line">  std::tuple&lt;</span><br><span class="line">    std::string, <span class="comment">// name</span></span><br><span class="line">    std::string,            <span class="comment">// email</span></span><br><span class="line">    std::<span class="type">size_t</span>&gt; ;          <span class="comment">// reputation</span></span><br><span class="line">UserInfo uInfo; <span class="comment">// object of tuple type</span></span><br><span class="line">…</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> val = std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(uInfo); <span class="comment">// get value of field 1</span></span><br><span class="line"><span class="comment">// 显然这里使用 get&lt;1&gt; 是想要得到 email 地址，然而这并不直观并且不易维护</span></span><br><span class="line"><span class="comment">// 利用 unscoped enums 可以改变这点</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">UserInfoFields</span> &#123; uiName, uiEmail, uiReputation &#125;;</span><br><span class="line">UserInfo uInfo; <span class="comment">// as before</span></span><br><span class="line">…</span><br><span class="line"><span class="keyword">auto</span> val = std::<span class="built_in">get</span>&lt;uiEmail&gt;(uInfo); <span class="comment">// ah, get value of</span></span><br><span class="line">                                     <span class="comment">// email field</span></span><br></pre></td></tr></table></figure>

<p>注意上面的代码使用了 unscoped enums 的隐式类型转换。<br>如果在这里想用使用 scoped enums 也行：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">UserInfoFields</span> &#123; uiName, uiEmail, uiReputation &#125;;</span><br><span class="line">UserInfo uInfo; <span class="comment">// as before</span></span><br><span class="line">…</span><br><span class="line"><span class="keyword">auto</span> val =</span><br><span class="line">  std::get&lt;<span class="built_in">static_cast</span>&lt;std::<span class="type">size_t</span>&gt;(UserInfoFields::uiEmail)&gt;(uInfo);</span><br></pre></td></tr></table></figure>

<p>但这显得有点繁杂，那是不是可以用一个返回 size_t 的函数代替 static_cast 呢？这是一个 tricky 的地方：std::get&lt; &gt; 是一个模板，尖括号里面的值的类型需要在编译时就能知道，否则编译器不能将模板实例化，从而导致编译失败。因此我们需要一个 constexpr 函数模板，它可以返回任意类型的 enum：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">typename</span> std::underlying_type&lt;E&gt;::<span class="function">type</span></span><br><span class="line"><span class="function">  <span class="title">toUType</span><span class="params">(E enumerator)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> std::underlying_type&lt;E&gt;::type&gt;(enumerator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C++14 可以改成：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E&gt; <span class="comment">// C++14</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> std::<span class="type">underlying_type_t</span>&lt;E&gt;</span></span><br><span class="line"><span class="function">  <span class="title">toUType</span><span class="params">(E enumerator)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;std::<span class="type">underlying_type_t</span>&lt;E&gt;&gt;(enumerator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或用上 auto：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E&gt; <span class="comment">// C++14</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span></span></span><br><span class="line"><span class="function">  <span class="title">toUType</span><span class="params">(E enumerator)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;std::<span class="type">underlying_type_t</span>&lt;E&gt;&gt;(enumerator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，获取 email 的信息可以这样用了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> val = std::<span class="built_in">get</span>&lt;<span class="built_in">toUType</span>(UserInfoFields::uiEmail)&gt;(uInfo);</span><br></pre></td></tr></table></figure>

<p><strong>Things to remember</strong></p>
<ul>
<li>C++98-style enums are now known as unscoped enums.</li>
<li>Enumerators of scoped enums are visible only within the enum. They convert to other types only with a cast.</li>
<li>Both scoped and unscoped enums support specification of the underlying type. The default underlying type for scoped enums is int. Unscoped enums have no default underlying type.</li>
<li>Scoped enums may always be forward-declared. Unscoped enums may be forward-declared only if their declaration specifies an underlying type.</li>
</ul>
<h2 id="Item-11-使用-deleted-函数而不是-private-undefined-函数"><a href="#Item-11-使用-deleted-函数而不是-private-undefined-函数" class="headerlink" title="Item 11:使用 deleted 函数而不是 private undefined 函数"></a>Item 11:使用 deleted 函数而不是 private undefined 函数</h2><p>如果你想避免其他开发者使用某些函数，一般来说不定义这个函数就行了（这不显然么）。然而其实并没那么显然，在定义一个类时，C++ 会自己定义一些函数（在 item 17(这里到时加个链接) 中有详细介绍）。比如流的拷贝问题。在C++ 标准库中有个 basic_ios 的模板类，所有的输出、输入流都继承自这个模板类。对流的拷贝的作用并不清楚，所以要避免用户对流进行拷贝。最简单的做法是做一个空的定义，下面的代码来自 C++98（包括注释）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">charT</span>, <span class="keyword">class</span> <span class="title class_">traits</span> = char_traits&lt;charT&gt; &gt;</span><br><span class="line"><span class="keyword">class</span> basic_ios : <span class="keyword">public</span> ios_base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">…</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">basic_ios</span>(<span class="type">const</span> basic_ios&amp; );           <span class="comment">// not defined</span></span><br><span class="line">  basic_ios&amp; <span class="keyword">operator</span>=(<span class="type">const</span> basic_ios&amp;); <span class="comment">// not defined</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但是这样的话成员函数或是友元都有权限使用 private 里面的函数。C++11 有更好的做法—— deleted functions:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">charT</span>, <span class="keyword">class</span> <span class="title class_">traits</span> = char_traits&lt;charT&gt; &gt;</span><br><span class="line"><span class="keyword">class</span> basic_ios : <span class="keyword">public</span> ios_base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">…</span><br><span class="line">  <span class="built_in">basic_ios</span>(<span class="type">const</span> basic_ios&amp; ) = <span class="keyword">delete</span>;</span><br><span class="line">  basic_ios&amp; <span class="keyword">operator</span>=(<span class="type">const</span> basic_ios&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">…</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用 delete 会让你在编译前就知道对这些函数的调用是不合法的，而若是友元等访问未定义的 private 函数，会在编译时才能知道。<br>有个小细节，deleted functions 是定义在 public 里的，原因是 C++ 会先检查函数的可访问性（accessibility），然后才检查函数的删除属性（deleted status）。如果放在 private 里面，C++ 可能只会说函数在 private 不能访问，而不是说该函数不能使用。因此，将代码的 private-and-not-defined 成员改成 public deleted 成员有益于改进 error 信息。  </p>
<p>另外，deleted functions 可以用在其他的非成员函数上，如我们定义一个函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isLucky</span><span class="params">(<span class="type">int</span> number)</span></span>;</span><br></pre></td></tr></table></figure>

<p>有这么一些对它的调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">isLucky</span>(<span class="string">&#x27;a&#x27;</span>)) … <span class="comment">// is &#x27;a&#x27; a lucky number?</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isLucky</span>(<span class="literal">true</span>)) … <span class="comment">// is &quot;true&quot;?</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isLucky</span>(<span class="number">3.5</span>)) … <span class="comment">// should we truncate to 3</span></span><br><span class="line">                    <span class="comment">// before checking for luckiness?</span></span><br></pre></td></tr></table></figure>

<p>如果我们想保证函数的输入只有整数的，可以使用 deleted function 来避免使用类型转换的合法类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isLucky</span><span class="params">(<span class="type">int</span> number)</span></span>; <span class="comment">// original function</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isLucky</span><span class="params">(<span class="type">char</span>)</span> </span>= <span class="keyword">delete</span>; <span class="comment">// reject chars</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isLucky</span><span class="params">(<span class="type">bool</span>)</span> </span>= <span class="keyword">delete</span>; <span class="comment">// reject bools</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isLucky</span><span class="params">(<span class="type">double</span>)</span> </span>= <span class="keyword">delete</span>; <span class="comment">// reject doubles and floats</span></span><br></pre></td></tr></table></figure>

<p>deleted functions 还能避免模板函数的不合适的实例化。比如我们有一个作用于内置指针的模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processPointer</span><span class="params">(T* ptr)</span></span>;</span><br></pre></td></tr></table></figure>

<p>在 C++ 中，有两类特殊的指针。一类是 void* 指针，因为它们不能被解引用或自增、自减；另一类是 char* 指针，因为它们指向的是 C 风格的字符串，而不是单个的 char。想避免使用这些指针类型的调用，可以用 deleted functions：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">processPointer</span>&lt;<span class="type">void</span>&gt;(<span class="type">void</span>*) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">processPointer</span>&lt;<span class="type">char</span>&gt;(<span class="type">char</span>*) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure>

<p>另外，使用 const void* 和 const char* 的调用也应该被避免：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">processPointer</span>&lt;<span class="type">const</span> <span class="type">void</span>&gt;(<span class="type">const</span> <span class="type">void</span>*) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">processPointer</span>&lt;<span class="type">const</span> <span class="type">char</span>&gt;(<span class="type">const</span> <span class="type">char</span>*) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure>

<p>如果还想彻底点，还有 const volatile void* 和 const volatile char* ，然而暂时不懂 volatile（划掉）。  </p>
<p>如果是在类里使用模板，像下面的代码是不会编译的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">…</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">  <span class="type">void</span> <span class="title">processPointer</span><span class="params">(T* ptr)</span></span></span><br><span class="line"><span class="function">  </span>&#123; … &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">template</span>&lt;&gt; <span class="comment">// error!</span></span><br><span class="line">  <span class="type">void</span> <span class="built_in">processPointer</span>&lt;<span class="type">void</span>&gt;(<span class="type">void</span>*);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其原因是对模板的特殊规定只能在命名空间（namespace scope）里写，而不能在类空间(class scope)。下面的代码可以实现上面代码的效果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  …</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">  <span class="type">void</span> <span class="title">processPointer</span><span class="params">(T* ptr)</span></span></span><br><span class="line"><span class="function">  </span>&#123; … &#125;</span><br><span class="line">  …</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; </span><br><span class="line"><span class="type">void</span> Widget::<span class="built_in">processPointer</span>&lt;<span class="type">void</span>&gt;(<span class="type">void</span>*) = <span class="keyword">delete</span>; <span class="comment">// still public but deleted</span></span><br></pre></td></tr></table></figure>

<p>总结一下，C++98 的 private-and-not-defined 成员实现的就是 C++11 中 deleted functions 实现的效果，但它在类外不能用，在类内不一定能用，就算能用了也要等到链接（link-time）时才能起作用。所以坚持使用 deleted functions 吧。  </p>
<p><strong>Things to Remember</strong></p>
<ul>
<li>Prefer deleted functions to private undefined ones.</li>
<li>Any function may be deleted, including non-member functions and template instantiations.</li>
</ul>
<h2 id="Item-12-将重写的函数声明为-override"><a href="#Item-12-将重写的函数声明为-override" class="headerlink" title="Item 12:将重写的函数声明为 override"></a>Item 12:将重写的函数声明为 override</h2><p>虚函数是 C++ 的类的一个工具。你可以在基类（base class）中定义或声明虚函数，并在派生类（derived classed）中重写（override）这个虚函数。然而何时该调用 overrided 的虚函数并不显然。先看下面这个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">doWork</span><span class="params">()</span></span>; <span class="comment">// base class virtual function</span></span><br><span class="line">…</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">doWork</span><span class="params">()</span></span>; <span class="comment">// overrides Base::doWork ,&quot;virtual&quot; is optional here</span></span><br><span class="line">  … </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// create base class pointer to derived class object;</span></span><br><span class="line"><span class="comment">// see Item 21 for info on std::make_unique</span></span><br><span class="line">std::unique_ptr&lt;Base&gt; upb = std::<span class="built_in">make_unique</span>&lt;Derived&gt;(); </span><br><span class="line">… </span><br><span class="line">upb-&gt;<span class="built_in">doWork</span>(); <span class="comment">// call doWork through base class ptr; derived class function is invoked</span></span><br></pre></td></tr></table></figure>

<p>上面这个例子，就是通过了一个基类的接口，调用了派生类的函数。<br>重写（Overring）的发生有以下几个必要要求：</p>
<ul>
<li>基类函数必须是<strong>虚函数（virtual）</strong></li>
<li>基类与派生类的该函数（下称基派函）<strong>同名</strong>（除了析构函数）</li>
<li>基派函<strong>参数一致</strong></li>
<li>基派函<strong>const 性（constness）一致</strong></li>
<li>基派函<strong>返回类型与 exception specifications 兼容（compatible)</strong></li>
</ul>
<p>C++11 还加了一点：  </p>
<ul>
<li>基派函<strong>引用限定符（reference qualifiers）一致</strong></li>
</ul>
<p>成员函数的引用限定符可以用来保证函数只被用于左值或右值，如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">…</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">()</span> &amp;</span>; <span class="comment">// this version of doWork applies only when *this is an lvalue</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">()</span> &amp;&amp;</span>; <span class="comment">// this version of doWork applies only when *this is an rvalue</span></span><br><span class="line">&#125;;                 </span><br><span class="line">…</span><br><span class="line"><span class="function">Widget <span class="title">makeWidget</span><span class="params">()</span></span>; <span class="comment">// factory function (returns rvalue)</span></span><br><span class="line">Widget w; <span class="comment">// normal object (an lvalue)</span></span><br><span class="line">…</span><br><span class="line">w.<span class="built_in">doWork</span>(); <span class="comment">// calls Widget::doWork for lvalues (i.e., Widget::doWork &amp;)</span></span><br><span class="line"><span class="built_in">makeWidget</span>().<span class="built_in">doWork</span>(); <span class="comment">// calls Widget::doWork for rvalues (i.e., Widget::doWork &amp;&amp;)</span></span><br></pre></td></tr></table></figure>

<p>由重写引起的错误并不会被编译器发现，因为它是往往合法的，只是没有按你的原目的进行。如下面的代码，就完全没有任何重写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf2</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf3</span><span class="params">()</span> &amp;</span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">mf4</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span></span>;               <span class="comment">// 没 const</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf2</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> x)</span></span>; <span class="comment">// 多了 unsigned</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf3</span><span class="params">()</span> &amp;&amp;</span>;            <span class="comment">// &amp; &amp;&amp;</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">mf4</span><span class="params">()</span> <span class="type">const</span></span>;                 <span class="comment">// base 不是 virtual</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>C++11 给出了避免上面这种情况的方案：把要重写的函数声明为 override：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf2</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> x)</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf3</span><span class="params">()</span> &amp;&amp; <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf4</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样，上面的代码就会因为重写失败而产生错误。</p>
<p>在 C++98 中也有 override：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Warning</span> &#123; <span class="comment">// potential legacy class from C++98</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">…</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">override</span><span class="params">()</span></span>; <span class="comment">// legal in both C++98 and C++11</span></span><br><span class="line">…                <span class="comment">// (with the same meaning)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>所以如果看见老代码用了 override 函数并不用改。<br>接下来补充一下引用限定符（reference qualifiers）的内容。假设有个Widget：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">using</span> DataType = std::vector&lt;<span class="type">double</span>&gt;; <span class="comment">// see Item 9 for</span></span><br><span class="line">	…                                     <span class="comment">// info on &quot;using&quot;</span></span><br><span class="line">	<span class="function">DataType&amp; <span class="title">data</span><span class="params">()</span> &amp; </span>&#123; <span class="keyword">return</span> values; &#125;</span><br><span class="line">	<span class="function">DataType <span class="title">data</span><span class="params">()</span> &amp;&amp; </span>&#123; <span class="keyword">return</span> std::<span class="built_in">move</span>(values); &#125;<span class="comment">// for rvalue Widgets, return rvalue</span></span><br><span class="line">	…</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">	DataType values;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给出两种调用</span></span><br><span class="line">Widget w;</span><br><span class="line">…</span><br><span class="line"><span class="keyword">auto</span> vals1 = w.<span class="built_in">data</span>(); <span class="comment">// copy w.values into vals1</span></span><br><span class="line"></span><br><span class="line"><span class="function">Widget <span class="title">makeWidget</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">auto</span> vals2 = <span class="built_in">makeWidget</span>().<span class="built_in">data</span>();</span><br></pre></td></tr></table></figure>

<p>这样，vals1 和 vals2 调用的是不同的 data() 函数。这就是 接受右值的函数定义 的作用。</p>
<p><strong>Things to Remember</strong></p>
<ul>
<li>Declare overriding functions override.</li>
<li>Member function reference qualifiers make it possible to treat lvalue and rvalue objects (*<strong>this</strong>) differently.</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Effective-Modern-C/" rel="tag"># Effective Modern C++</a>
              <a href="/tags/C/" rel="tag"># C++</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/08/11/EMC-notes-2/" rel="prev" title="auto - Effective Modern C++阅读笔记（二）">
      <i class="fa fa-chevron-left"></i> auto - Effective Modern C++阅读笔记（二）
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/08/11/Universal-Reference/" rel="next" title="Universal Reference in C++11">
      Universal Reference in C++11 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Moving-to-Modern-C"><span class="nav-number">1.</span> <span class="nav-text">Moving to Modern C++</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Item-7-%E8%BE%A8%E5%88%AB%E7%94%9F%E6%88%90%E5%AF%B9%E8%B1%A1%E6%97%B6-%E5%92%8C-%E7%9A%84%E4%B8%8D%E5%90%8C"><span class="nav-number">1.1.</span> <span class="nav-text">Item 7:辨别生成对象时()和{}的不同</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Item-8-%E5%A4%9A%E7%94%A8-nullptr-%E4%BB%A3%E6%9B%BF-0-%E5%92%8C-null"><span class="nav-number">1.2.</span> <span class="nav-text">Item 8:多用 nullptr 代替 0 和 null</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Item-9-%E5%A4%9A%E7%94%A8-alias-declarations-%E8%80%8C%E4%B8%8D%E6%98%AF-typedefs"><span class="nav-number">1.3.</span> <span class="nav-text">Item 9:多用 alias declarations 而不是 typedefs</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Item-10-%E5%A4%9A%E7%94%A8-scoped-enums-%E8%80%8C%E4%B8%8D%E6%98%AF-unscoped-enums"><span class="nav-number">1.4.</span> <span class="nav-text">Item 10:多用 scoped enums 而不是 unscoped enums</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Item-11-%E4%BD%BF%E7%94%A8-deleted-%E5%87%BD%E6%95%B0%E8%80%8C%E4%B8%8D%E6%98%AF-private-undefined-%E5%87%BD%E6%95%B0"><span class="nav-number">1.5.</span> <span class="nav-text">Item 11:使用 deleted 函数而不是 private undefined 函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Item-12-%E5%B0%86%E9%87%8D%E5%86%99%E7%9A%84%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E4%B8%BA-override"><span class="nav-number">1.6.</span> <span class="nav-text">Item 12:将重写的函数声明为 override</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">wizlyk</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">8</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wizlyk</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
